/******/ (function() { // webpackBootstrap
/*!*************************************************************!*\
  !*** ./src/workers/FramesToVideo/worker-frames-to-video.js ***!
  \*************************************************************/
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/Worker/Core/Encoder/constants.ts":
/*!**********************************************!*\
  !*** ./src/Worker/Core/Encoder/constants.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getEncoderIndexFromInstanceKey = exports.getEncoderInstanceKey = exports.MAXIMUM_MUXER_DURATION = exports.MUXER_DURATION_SEC = exports.SECOND = void 0;\n// export enum EncoderEvent {\n//   loaded = \"loaded\",\n//   loadFailed = \"loadFailed\",\n// }\nexports.SECOND = 1000;\nexports.MUXER_DURATION_SEC = 30;\nexports.MAXIMUM_MUXER_DURATION = exports.MUXER_DURATION_SEC * exports.SECOND;\nvar encoderInstancePrefix = \"segment\";\nvar getEncoderInstanceKey = function (id, index) {\n    return \"\".concat(encoderInstancePrefix, \"-\").concat(id, \"-\").concat(index);\n};\nexports.getEncoderInstanceKey = getEncoderInstanceKey;\nvar getEncoderIndexFromInstanceKey = function (instanceKey, id) { return +instanceKey.replace(\"\".concat(encoderInstancePrefix, \"-\").concat(id, \"-\"), \"\"); };\nexports.getEncoderIndexFromInstanceKey = getEncoderIndexFromInstanceKey;\n\n\n//# sourceURL=webpack://rf-video-editor-worker/./src/Worker/Core/Encoder/constants.ts?");

/***/ }),

/***/ "./src/Worker/Core/Encoder/index.ts":
/*!******************************************!*\
  !*** ./src/Worker/Core/Encoder/index.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar webm_muxer_1 = __webpack_require__(/*! webm-muxer */ \"./node_modules/webm-muxer/build/webm-muxer.js\");\nvar EventEmitter_1 = __webpack_require__(/*! ../EventEmitter */ \"./src/Worker/Core/EventEmitter/index.ts\");\nvar types_1 = __webpack_require__(/*! ./types */ \"./src/Worker/Core/Encoder/types.ts\");\nvar constants_1 = __webpack_require__(/*! ./constants */ \"./src/Worker/Core/Encoder/constants.ts\");\nvar Encoder = /** @class */ (function (_super) {\n    __extends(Encoder, _super);\n    function Encoder(instanceKey) {\n        var _this = _super.call(this) || this;\n        _this.instanceKey = instanceKey;\n        _this.segmentIndex = 0;\n        _this.nextFrameIndex = 0;\n        _this.videoFramesData = [];\n        _this.encoder = null;\n        _this.totalFramesCount = 0;\n        _this.totalDuration = 0;\n        _this.config = null;\n        _this.muxer = null;\n        return _this;\n    }\n    Encoder.getInstance = function (key) {\n        if (!this.instanceMap.has(key)) {\n            this.instanceMap.set(key, new this(key));\n        }\n        return this.instanceMap.get(key);\n    };\n    Encoder.removeInstance = function (key) {\n        if (!this.instanceMap.has(key)) {\n            return;\n        }\n        var instance = this.getInstance(key);\n        instance.destroy();\n        this.instanceMap.delete(key);\n    };\n    Encoder.removeAllInstances = function () {\n        this.instanceMap.clear();\n    };\n    Encoder.prototype.initialize = function (config, totalDuration) {\n        if (totalDuration === void 0) { totalDuration = constants_1.MUXER_DURATION_SEC; }\n        this.totalDuration = totalDuration;\n        this.encoder = new VideoEncoder({\n            output: this.handleVideoChunk.bind(this),\n            error: this.handleError.bind(this),\n        });\n        this.config = config;\n        this.encoder.configure(this.config);\n        this.totalFramesCount = (this.totalDuration * config.framerate) / 1000;\n        this.muxer = new webm_muxer_1.Muxer({\n            target: new webm_muxer_1.ArrayBufferTarget(),\n            video: {\n                codec: \"V_VP9\",\n                width: config.width,\n                height: config.height,\n                frameRate: config.framerate,\n                alpha: false,\n            },\n        });\n    };\n    Encoder.prototype.addFrame = function (frameData) {\n        this.videoFramesData.push(frameData);\n        this.processFrames();\n    };\n    Encoder.prototype.processFrames = function () {\n        var _this = this;\n        if (!this.encoder || !this.config) {\n            console.warn(\"Encoder with instance key \\\"\".concat(this.instanceKey, \"\\\" is not initialized.\"));\n            return;\n        }\n        if (this.encoder.state === \"closed\") {\n            console.warn(\"Encoder with instance key \\\"\".concat(this.instanceKey, \"\\\" is closed\"));\n            return;\n        }\n        if (this.nextFrameIndex >= this.totalFramesCount) {\n            this.finalizeVideo();\n            return;\n        }\n        var nextFrameDataIndex = this.videoFramesData.findIndex(function (frameData) { return frameData.index === _this.nextFrameIndex; });\n        var nextFrameData = this.videoFramesData[nextFrameDataIndex];\n        if (!nextFrameData) {\n            return;\n        }\n        this.encoder.encode(nextFrameData.frame);\n        nextFrameData.frame.close();\n        this.videoFramesData.splice(nextFrameDataIndex, 1);\n        this.nextFrameIndex++;\n        this.processFrames();\n    };\n    Encoder.prototype.finalizeVideo = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var buffer;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!this.encoder || !this.muxer) {\n                            return [2 /*return*/];\n                        }\n                        return [4 /*yield*/, this.encoder.flush()];\n                    case 1:\n                        _a.sent();\n                        this.encoder.close();\n                        this.encoder = null;\n                        this.muxer.finalize();\n                        buffer = this.muxer.target.buffer;\n                        this.emit(types_1.EncoderEvent.finalized, buffer, this.instanceKey);\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    Encoder.prototype.handleVideoChunk = function (chunk, metadata) {\n        if (!this.muxer) {\n            return;\n        }\n        this.muxer.addVideoChunk(chunk, metadata);\n    };\n    Encoder.prototype.handleError = function (error) {\n        this.emit(types_1.EncoderEvent.error, error);\n    };\n    Encoder.prototype.destroy = function () {\n        var _a;\n        this.muxer = null;\n        (_a = this.encoder) === null || _a === void 0 ? void 0 : _a.reset();\n        this.config = null;\n        this.videoFramesData = [];\n    };\n    Encoder.instanceMap = new Map();\n    return Encoder;\n}(EventEmitter_1.EventEmitter));\nexports[\"default\"] = Encoder;\n\n\n//# sourceURL=webpack://rf-video-editor-worker/./src/Worker/Core/Encoder/index.ts?");

/***/ }),

/***/ "./src/Worker/Core/Encoder/types.ts":
/*!******************************************!*\
  !*** ./src/Worker/Core/Encoder/types.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EncoderEvent = void 0;\nvar EncoderEvent;\n(function (EncoderEvent) {\n    EncoderEvent[\"error\"] = \"error\";\n    EncoderEvent[\"frameDone\"] = \"frameDone\";\n    EncoderEvent[\"finalized\"] = \"finalized\";\n})(EncoderEvent || (exports.EncoderEvent = EncoderEvent = {}));\n\n\n//# sourceURL=webpack://rf-video-editor-worker/./src/Worker/Core/Encoder/types.ts?");

/***/ }),

/***/ "./src/Worker/Core/EventEmitter/index.ts":
/*!***********************************************!*\
  !*** ./src/Worker/Core/EventEmitter/index.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EventEmitter = void 0;\nvar EventEmitter = /** @class */ (function () {\n    function EventEmitter() {\n        this.eventsMap = new Map();\n    }\n    EventEmitter.prototype.on = function (eventName, callback, context, once) {\n        if (this.getEventListeners(eventName) === null) {\n            this.eventsMap.set(eventName, []);\n        }\n        this.getEventListeners(eventName).push({\n            once: once || false,\n            callback: callback,\n            context: context,\n        });\n        return this;\n    };\n    EventEmitter.prototype.once = function (eventName, callback, context) {\n        return this.on(eventName, callback, context, true);\n    };\n    EventEmitter.prototype.off = function (eventName, callback, context) {\n        var listeners = this.getEventListeners(eventName);\n        if (!listeners || !listeners.length) {\n            return;\n        }\n        var targetListener = {\n            callback: callback,\n            context: context,\n        };\n        var targetIndex = listeners.findIndex(function (listener) {\n            return listener.callback === targetListener.callback &&\n                listener.context === targetListener.context;\n        });\n        if (listeners.length <= 1) {\n            this.eventsMap.delete(eventName);\n        }\n        else {\n            listeners.splice(targetIndex, 1);\n        }\n        return this;\n    };\n    EventEmitter.prototype.removeAllListeners = function () {\n        this.eventsMap.clear();\n    };\n    EventEmitter.prototype.emit = function (eventName) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        var listeners = this.getEventListeners(eventName);\n        if (!listeners) {\n            return this;\n        }\n        listeners.forEach(function (listener) {\n            var _a;\n            (_a = listener.callback).bind.apply(_a, __spreadArray([listener.context], args, false))();\n        });\n        return this;\n    };\n    EventEmitter.prototype.getEventListeners = function (eventName) {\n        var _a;\n        return (_a = this.eventsMap.get(eventName)) !== null && _a !== void 0 ? _a : null;\n    };\n    return EventEmitter;\n}());\nexports.EventEmitter = EventEmitter;\n\n\n//# sourceURL=webpack://rf-video-editor-worker/./src/Worker/Core/EventEmitter/index.ts?");

/***/ }),

/***/ "./src/Worker/Core/IndexedDB/index.ts":
/*!********************************************!*\
  !*** ./src/Worker/Core/IndexedDB/index.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar IndexedDB = /** @class */ (function () {\n    function IndexedDB(DB_NAME) {\n        this.DB_NAME = DB_NAME;\n        this.version = null;\n    }\n    IndexedDB.getInstance = function (DB_NAME) {\n        if (!this.instanceMap.get(DB_NAME)) {\n            this.instanceMap.set(DB_NAME, new this(DB_NAME));\n        }\n        return this.instanceMap.get(DB_NAME);\n    };\n    IndexedDB.prototype.openDatabase = function (dbTable) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _this = this;\n            return __generator(this, function (_a) {\n                return [2 /*return*/, new Promise(function (resolve, reject) {\n                        var request = indexedDB.open(_this.DB_NAME, _this.version ? _this.version : undefined);\n                        request.onupgradeneeded = function (event) {\n                            var db = event.target.result;\n                            var tables = [\"frame\", \"video-segment\"];\n                            for (var _i = 0, tables_1 = tables; _i < tables_1.length; _i++) {\n                                var table = tables_1[_i];\n                                if (!db.objectStoreNames.contains(table)) {\n                                    db.createObjectStore(table, {\n                                        keyPath: \"id\",\n                                        autoIncrement: true,\n                                    });\n                                }\n                            }\n                        };\n                        request.onsuccess = function (event) { return __awaiter(_this, void 0, void 0, function () {\n                            var db, newDb;\n                            return __generator(this, function (_a) {\n                                switch (_a.label) {\n                                    case 0:\n                                        db = event.target.result;\n                                        if (!this.version) {\n                                            this.version = db.version;\n                                        }\n                                        if (!!db.objectStoreNames.contains(dbTable)) return [3 /*break*/, 2];\n                                        this.version++;\n                                        db.close();\n                                        return [4 /*yield*/, this.openDatabase(dbTable)];\n                                    case 1:\n                                        newDb = _a.sent();\n                                        resolve(newDb);\n                                        return [3 /*break*/, 3];\n                                    case 2:\n                                        resolve(db);\n                                        _a.label = 3;\n                                    case 3: return [2 /*return*/];\n                                }\n                            });\n                        }); };\n                        request.onerror = function (event) {\n                            reject(event.target.error);\n                        };\n                    })];\n            });\n        });\n    };\n    IndexedDB.prototype.saveRecord = function (dbTable, data) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _this = this;\n            return __generator(this, function (_a) {\n                return [2 /*return*/, new Promise(function (resolve, reject) {\n                        _this.openDatabase(dbTable).then(function (db) {\n                            var transaction = db.transaction(dbTable, \"readwrite\");\n                            var store = transaction.objectStore(dbTable);\n                            var request = store.add(data);\n                            request.onsuccess = function () {\n                                resolve(request.result);\n                            };\n                            request.onerror = function () { return reject(request.error); };\n                        });\n                    })];\n            });\n        });\n    };\n    IndexedDB.prototype.readRecord = function (id, dbTable) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this.openDatabase(dbTable).then(function (db) {\n                        return new Promise(function (resolve, reject) {\n                            var transaction = db.transaction(dbTable, \"readonly\");\n                            var store = transaction.objectStore(dbTable);\n                            var request = store.get(id);\n                            request.onsuccess = function () {\n                                resolve(request.result);\n                            };\n                            request.onerror = function () {\n                                reject(request.error);\n                            };\n                        });\n                    })];\n            });\n        });\n    };\n    IndexedDB.prototype.readAllRecords = function (dbTable) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this.openDatabase(dbTable).then(function (db) {\n                        return new Promise(function (resolve, reject) {\n                            var transaction = db.transaction(dbTable, \"readonly\");\n                            var store = transaction.objectStore(dbTable);\n                            var request = store.getAll();\n                            request.onsuccess = function () {\n                                resolve(request.result);\n                            };\n                            request.onerror = function () {\n                                reject(request.error);\n                            };\n                        });\n                    })];\n            });\n        });\n    };\n    IndexedDB.prototype.deleteRecord = function (dbTable, id) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this.openDatabase(dbTable).then(function (db) {\n                        return new Promise(function (resolve, reject) {\n                            var transaction = db.transaction(dbTable, \"readwrite\");\n                            var store = transaction.objectStore(dbTable);\n                            var request = store.delete(id);\n                            request.onsuccess = function () { return resolve(); };\n                            request.onerror = function () { return reject(request.error); };\n                        });\n                    })];\n            });\n        });\n    };\n    IndexedDB.prototype.updateRecord = function (dbTable, id, data) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this.openDatabase(dbTable).then(function (db) {\n                        return new Promise(function (resolve, reject) {\n                            var transaction = db.transaction(dbTable, \"readwrite\");\n                            var store = transaction.objectStore(dbTable);\n                            var getRequest = store.get(id);\n                            getRequest.onsuccess = function () {\n                                var existingData = getRequest.result;\n                                if (existingData) {\n                                    var updatedData = __assign(__assign({}, existingData), data);\n                                    var updateRequest_1 = store.put(updatedData, id);\n                                    updateRequest_1.onsuccess = resolve;\n                                    updateRequest_1.onerror = function () { return reject(updateRequest_1.error); };\n                                }\n                                else {\n                                    reject(\"Record not found\");\n                                }\n                            };\n                            getRequest.onerror = function () { return reject(getRequest.error); };\n                        });\n                    })];\n            });\n        });\n    };\n    IndexedDB.prototype.clearTable = function (dbTable) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this.openDatabase(dbTable).then(function (db) {\n                        return new Promise(function (resolve, reject) {\n                            var transaction = db.transaction(dbTable, \"readwrite\");\n                            var store = transaction.objectStore(dbTable);\n                            var request = store.clear();\n                            request.onsuccess = function () { return resolve(); };\n                            request.onerror = function () { return reject(request.error); };\n                        });\n                    })];\n            });\n        });\n    };\n    IndexedDB.instanceMap = new Map();\n    return IndexedDB;\n}());\nexports[\"default\"] = IndexedDB;\n\n\n//# sourceURL=webpack://rf-video-editor-worker/./src/Worker/Core/IndexedDB/index.ts?");

/***/ }),

/***/ "./src/Worker/constants.ts":
/*!*********************************!*\
  !*** ./src/Worker/constants.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DB_Name = exports.OutgoingMessage = exports.IncomingMessage = void 0;\nvar IncomingMessage;\n(function (IncomingMessage) {\n    IncomingMessage[\"initialize\"] = \"initialize\";\n    IncomingMessage[\"initializeJob\"] = \"initializeJob\";\n    IncomingMessage[\"addFrameToQueue\"] = \"addFrameToQueue\";\n})(IncomingMessage || (exports.IncomingMessage = IncomingMessage = {}));\nvar OutgoingMessage;\n(function (OutgoingMessage) {\n    OutgoingMessage[\"initialized\"] = \"initialized\";\n    OutgoingMessage[\"initializedJob\"] = \"initializedJob\";\n    OutgoingMessage[\"encodingComplete\"] = \"encodingComplete\";\n})(OutgoingMessage || (exports.OutgoingMessage = OutgoingMessage = {}));\nexports.DB_Name = \"frames-to-video\";\n\n\n//# sourceURL=webpack://rf-video-editor-worker/./src/Worker/constants.ts?");

/***/ }),

/***/ "./src/Worker/index.ts":
/*!*****************************!*\
  !*** ./src/Worker/index.ts ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar constants_1 = __webpack_require__(/*! ./constants */ \"./src/Worker/constants.ts\");\nvar Encoder_1 = __webpack_require__(/*! ./Core/Encoder */ \"./src/Worker/Core/Encoder/index.ts\");\nvar IndexedDB_1 = __webpack_require__(/*! ./Core/IndexedDB */ \"./src/Worker/Core/IndexedDB/index.ts\");\nvar logger_1 = __webpack_require__(/*! ./utils/logger */ \"./src/Worker/utils/logger/index.ts\");\nvar constants_2 = __webpack_require__(/*! ./Core/Encoder/constants */ \"./src/Worker/Core/Encoder/constants.ts\");\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./src/Worker/utils/index.ts\");\nvar types_1 = __webpack_require__(/*! ./Core/Encoder/types */ \"./src/Worker/Core/Encoder/types.ts\");\nvar Worker = /** @class */ (function () {\n    function Worker() {\n        var _this = this;\n        this.indexedDb = null;\n        this.job = null;\n        this.segmentPromises = [];\n        this.jobStartMoment = 0;\n        self.onmessage = function (message) { return _this.handleMessage(message); };\n    }\n    Worker.prototype.initialize = function (data) {\n        if (this.id) {\n            return;\n        }\n        this.id = data.id;\n    };\n    Worker.prototype.cleanUp = function () {\n        if (!this.indexedDb) {\n            return;\n        }\n        Encoder_1.default.removeAllInstances();\n    };\n    Worker.prototype.initializeJob = function (job) {\n        this.job = job;\n        this.cleanUp();\n        this.indexedDb = IndexedDB_1.default.getInstance(constants_1.DB_Name);\n        this.createEncoderInstances();\n        this.handleJobCompletion();\n        this.jobStartMoment = Date.now();\n    };\n    Worker.prototype.handleJobCompletion = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var initializationData;\n            var _this = this;\n            return __generator(this, function (_a) {\n                initializationData = {\n                    id: this.id,\n                    jobId: this.job.id,\n                };\n                this.sendMessage({\n                    event: constants_1.OutgoingMessage.initializedJob,\n                    data: initializationData,\n                });\n                Promise.all(this.segmentPromises).then(function (segments) {\n                    var completionData = {\n                        id: _this.id,\n                        jobId: _this.job.id,\n                        segments: segments,\n                    };\n                    _this.sendMessage({\n                        event: constants_1.OutgoingMessage.encodingComplete,\n                        data: completionData,\n                    });\n                });\n                return [2 /*return*/];\n            });\n        });\n    };\n    Worker.prototype.createEncoderInstances = function () {\n        var _this = this;\n        if (!this.job) {\n            return;\n        }\n        var segmentsCount = Math.ceil(this.job.totalDuration / constants_2.MAXIMUM_MUXER_DURATION);\n        var config = {\n            codec: \"vp09.00.10.08\",\n            width: this.job.displayWidth,\n            height: this.job.displayHeight,\n            latencyMode: \"quality\",\n            framerate: this.job.fps,\n            bitrate: 1000000,\n            bitrateMode: \"constant\",\n        };\n        var _loop_1 = function (i) {\n            var promise = new Promise(function (resolve, reject) {\n                var instanceKey = (0, constants_2.getEncoderInstanceKey)(_this.id, i);\n                var encoder = Encoder_1.default.getInstance(instanceKey);\n                var segmentIndex = (0, constants_2.getEncoderIndexFromInstanceKey)(encoder.instanceKey, _this.id);\n                var onSegmentComplete = function (buffer) { return __awaiter(_this, void 0, void 0, function () {\n                    var blob, videoSegmentData, segmentId, segmentData;\n                    return __generator(this, function (_a) {\n                        switch (_a.label) {\n                            case 0:\n                                blob = new Blob([buffer], { type: \"video/webm\" });\n                                videoSegmentData = {\n                                    segmentIndex: segmentIndex,\n                                    blob: blob,\n                                };\n                                return [4 /*yield*/, this.indexedDb.saveRecord(\"video-segment\", videoSegmentData)];\n                            case 1:\n                                segmentId = _a.sent();\n                                segmentData = {\n                                    segmentId: segmentId,\n                                    segmentIndex: segmentIndex,\n                                };\n                                encoder.removeAllListeners();\n                                Encoder_1.default.removeInstance(encoder.instanceKey);\n                                resolve(segmentData);\n                                return [2 /*return*/];\n                        }\n                    });\n                }); };\n                var onSegmentFailed = function (error) {\n                    encoder.removeAllListeners();\n                    Encoder_1.default.removeInstance(encoder.instanceKey);\n                    (0, logger_1.logError)(\"Frames To Video - \".concat(_this.id, \" | Failed to generate segment \").concat(segmentIndex), error);\n                    reject(error);\n                };\n                var segmentStartsAt = segmentIndex * constants_2.MAXIMUM_MUXER_DURATION;\n                var remainingDuration = _this.job.totalDuration - segmentStartsAt;\n                var segmentDuration = Math.min(constants_2.MAXIMUM_MUXER_DURATION, remainingDuration);\n                encoder.initialize(config, segmentDuration);\n                encoder.once(types_1.EncoderEvent.finalized, onSegmentComplete);\n                encoder.once(types_1.EncoderEvent.error, onSegmentFailed);\n            });\n            this_1.segmentPromises.push(promise);\n        };\n        var this_1 = this;\n        for (var i = 0; i < segmentsCount; i++) {\n            _loop_1(i);\n        }\n    };\n    Worker.prototype.addFrameToQueue = function (data) {\n        return __awaiter(this, void 0, void 0, function () {\n            var id, frameData, imageBitmap, indexInSegment, segmentIndex, frame, encoderInstanceKey, videoFramesData, encoder;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!this.indexedDb) {\n                            return [2 /*return*/];\n                        }\n                        id = data.id;\n                        return [4 /*yield*/, this.indexedDb.readRecord(id, \"frame\")];\n                    case 1:\n                        frameData = _a.sent();\n                        this.indexedDb.deleteRecord(\"frame\", id);\n                        return [4 /*yield*/, this.getImageBitmapFromContent(frameData)];\n                    case 2:\n                        imageBitmap = _a.sent();\n                        indexInSegment = frameData.index % this.framesCountPerSegment;\n                        segmentIndex = Math.floor(frameData.index / this.framesCountPerSegment);\n                        frame = (0, utils_1.imageBitmapToVideoFrame)(imageBitmap, frameData, segmentIndex);\n                        encoderInstanceKey = (0, constants_2.getEncoderInstanceKey)(this.id, segmentIndex);\n                        videoFramesData = {\n                            index: indexInSegment,\n                            frame: frame,\n                        };\n                        encoder = Encoder_1.default.getInstance(encoderInstanceKey);\n                        encoder.addFrame(videoFramesData);\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    Worker.prototype.getImageBitmapFromContent = function (frameData) {\n        return __awaiter(this, void 0, void 0, function () {\n            var width, height, imageData;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!(typeof frameData.content === \"string\")) return [3 /*break*/, 2];\n                        return [4 /*yield*/, (0, utils_1.base64ToImageBitmap)(frameData.content)];\n                    case 1: return [2 /*return*/, _a.sent()];\n                    case 2:\n                        width = frameData.displayWidth;\n                        height = frameData.displayHeight;\n                        imageData = new ImageData(new Uint8ClampedArray(frameData.content), width, height);\n                        return [4 /*yield*/, createImageBitmap(imageData)];\n                    case 3: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    Worker.prototype.handleMessage = function (message, onDefault) {\n        if (onDefault === void 0) { onDefault = this\n            .onMessageNotHandled; }\n        var _a = message.data, event = _a.event, data = _a.data;\n        switch (event) {\n            case constants_1.IncomingMessage.initialize:\n                this.initialize(data);\n                break;\n            case constants_1.IncomingMessage.initializeJob:\n                this.initializeJob(data);\n                break;\n            case constants_1.IncomingMessage.addFrameToQueue:\n                this.addFrameToQueue(data);\n                break;\n            default:\n                onDefault(message);\n                break;\n        }\n    };\n    Worker.prototype.onMessageNotHandled = function (message) {\n        var event = message.data.event;\n        (0, logger_1.logError)(\"\".concat(event, \" is not handled\"));\n    };\n    Worker.prototype.sendMessage = function (data, transfer) {\n        if (transfer === void 0) { transfer = []; }\n        self.postMessage(data, transfer);\n    };\n    Object.defineProperty(Worker.prototype, \"framesCountPerSegment\", {\n        get: function () {\n            if (!this.job) {\n                return 0;\n            }\n            return constants_2.MUXER_DURATION_SEC * this.job.fps;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Worker;\n}());\nexports[\"default\"] = Worker;\n\n\n//# sourceURL=webpack://rf-video-editor-worker/./src/Worker/index.ts?");

/***/ }),

/***/ "./src/Worker/utils/index.ts":
/*!***********************************!*\
  !*** ./src/Worker/utils/index.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.imageBitmapToVideoFrame = exports.base64ToImageBitmap = exports.getArrayBufferFromFile = void 0;\nvar constants_1 = __webpack_require__(/*! ../Core/Encoder/constants */ \"./src/Worker/Core/Encoder/constants.ts\");\nvar getArrayBufferFromFile = function (file) { return __awaiter(void 0, void 0, void 0, function () {\n    return __generator(this, function (_a) {\n        return [2 /*return*/, new Promise(function (resolve, reject) {\n                var reader = new FileReader();\n                reader.onload = function () {\n                    resolve(reader.result);\n                };\n                reader.onerror = function () { return reject(reader.error); };\n                reader.readAsArrayBuffer(file);\n            })];\n    });\n}); };\nexports.getArrayBufferFromFile = getArrayBufferFromFile;\nvar base64ToImageBitmap = function (base64) { return __awaiter(void 0, void 0, void 0, function () {\n    var base64String, byteCharacters, byteArrays, offset, slice, byteNumbers, i, byteArray, blob;\n    return __generator(this, function (_a) {\n        switch (_a.label) {\n            case 0:\n                base64String = base64.split(\",\")[1];\n                byteCharacters = atob(base64String);\n                byteArrays = [];\n                for (offset = 0; offset < byteCharacters.length; offset += 1024) {\n                    slice = byteCharacters.slice(offset, offset + 1024);\n                    byteNumbers = new Array(slice.length);\n                    for (i = 0; i < slice.length; i++) {\n                        byteNumbers[i] = slice.charCodeAt(i);\n                    }\n                    byteArray = new Uint8Array(byteNumbers);\n                    byteArrays.push(byteArray);\n                }\n                blob = new Blob(byteArrays, { type: \"image/webp\" });\n                return [4 /*yield*/, createImageBitmap(blob)];\n            case 1: return [2 /*return*/, _a.sent()];\n        }\n    });\n}); };\nexports.base64ToImageBitmap = base64ToImageBitmap;\nvar imageBitmapToVideoFrame = function (imageBitmap, frameData, segmentIndex) {\n    var index = frameData.index, base64Content = frameData.content, rest = __rest(frameData, [\"index\", \"content\"]);\n    if (rest.timestamp !== undefined) {\n        rest.timestamp -= segmentIndex * constants_1.MAXIMUM_MUXER_DURATION * 1000;\n    }\n    return new VideoFrame(imageBitmap, rest);\n};\nexports.imageBitmapToVideoFrame = imageBitmapToVideoFrame;\n\n\n//# sourceURL=webpack://rf-video-editor-worker/./src/Worker/utils/index.ts?");

/***/ }),

/***/ "./src/Worker/utils/logger/index.ts":
/*!******************************************!*\
  !*** ./src/Worker/utils/logger/index.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\n/* eslint-disable */\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.logWorkerEvent = exports.logResponse = exports.logReject = exports.logError = exports.logCall = exports.logDebug = void 0;\nvar write = function (backgroundColor, fontColor, text) {\n    var args = [];\n    for (var _i = 3; _i < arguments.length; _i++) {\n        args[_i - 3] = arguments[_i];\n    }\n    var consoleArgs = [\n        \"\",\n        \"background: \".concat(\"#c8c8ff\", \";\"),\n        \"background: \".concat(\"#9696ff\", \";\"),\n        \"color: \".concat(fontColor, \"; background: \").concat(backgroundColor, \";\"),\n        \"background: \".concat(\"#9696ff\", \";\"),\n        \"background: \".concat(\"#c8c8ff\", \";\"),\n    ];\n    var isString = typeof text === \"string\";\n    !isString && args.unshift(text);\n    consoleArgs[0] = \"%c %c %c \".concat(isString ? text : \"log\", \" %c %c\");\n    if (args.length) {\n        console.groupCollapsed.apply(console, consoleArgs);\n        for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {\n            var arg = args_1[_a];\n            console.log(arg);\n        }\n        console.groupEnd();\n    }\n    else {\n        console.log.apply(console, consoleArgs);\n    }\n    return;\n};\nvar logDebug = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return write.apply(void 0, __spreadArray([\"#0000ff\", \"#ffffff\", args.shift()], args, false));\n};\nexports.logDebug = logDebug;\nvar logCall = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return write.apply(void 0, __spreadArray([\"#9e9e9e\", \"#ffffff\", args.shift()], args, false));\n};\nexports.logCall = logCall;\nvar logError = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return write.apply(void 0, __spreadArray([\"#ff0000\", \"#ffffff\", args.shift()], args, false));\n};\nexports.logError = logError;\nvar logReject = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return write.apply(void 0, __spreadArray([\"#8B0000\", \"#ffffff\", args.shift()], args, false));\n};\nexports.logReject = logReject;\nvar logResponse = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return write.apply(void 0, __spreadArray([\"#308751\", \"#ffffff\", args.shift()], args, false));\n};\nexports.logResponse = logResponse;\nvar logWorkerEvent = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return write.apply(void 0, __spreadArray([\"#FFA500\", \"#000000\", args.shift()], args, false));\n};\nexports.logWorkerEvent = logWorkerEvent;\n\n\n//# sourceURL=webpack://rf-video-editor-worker/./src/Worker/utils/logger/index.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar Worker_1 = __webpack_require__(/*! ./Worker */ \"./src/Worker/index.ts\");\nnew Worker_1.default();\n\n\n//# sourceURL=webpack://rf-video-editor-worker/./src/index.ts?");

/***/ }),

/***/ "./node_modules/webm-muxer/build/webm-muxer.js":
/*!*****************************************************!*\
  !*** ./node_modules/webm-muxer/build/webm-muxer.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\nvar WebMMuxer = (() => {\n  var __defProp = Object.defineProperty;\n  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __export = (target, all) => {\n    for (var name in all)\n      __defProp(target, name, { get: all[name], enumerable: true });\n  };\n  var __copyProps = (to, from, except, desc) => {\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n      for (let key of __getOwnPropNames(from))\n        if (!__hasOwnProp.call(to, key) && key !== except)\n          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n    }\n    return to;\n  };\n  var __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n  var __accessCheck = (obj, member, msg) => {\n    if (!member.has(obj))\n      throw TypeError(\"Cannot \" + msg);\n  };\n  var __privateGet = (obj, member, getter) => {\n    __accessCheck(obj, member, \"read from private field\");\n    return getter ? getter.call(obj) : member.get(obj);\n  };\n  var __privateAdd = (obj, member, value) => {\n    if (member.has(obj))\n      throw TypeError(\"Cannot add the same private member more than once\");\n    member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n  };\n  var __privateSet = (obj, member, value, setter) => {\n    __accessCheck(obj, member, \"write to private field\");\n    setter ? setter.call(obj, value) : member.set(obj, value);\n    return value;\n  };\n  var __privateMethod = (obj, member, method) => {\n    __accessCheck(obj, member, \"access private method\");\n    return method;\n  };\n\n  // src/index.ts\n  var src_exports = {};\n  __export(src_exports, {\n    ArrayBufferTarget: () => ArrayBufferTarget,\n    FileSystemWritableFileStreamTarget: () => FileSystemWritableFileStreamTarget,\n    Muxer: () => Muxer,\n    StreamTarget: () => StreamTarget,\n    SubtitleEncoder: () => SubtitleEncoder\n  });\n\n  // src/ebml.ts\n  var EBMLFloat32 = class {\n    constructor(value) {\n      this.value = value;\n    }\n  };\n  var EBMLFloat64 = class {\n    constructor(value) {\n      this.value = value;\n    }\n  };\n  var measureUnsignedInt = (value) => {\n    if (value < 1 << 8) {\n      return 1;\n    } else if (value < 1 << 16) {\n      return 2;\n    } else if (value < 1 << 24) {\n      return 3;\n    } else if (value < 2 ** 32) {\n      return 4;\n    } else if (value < 2 ** 40) {\n      return 5;\n    } else {\n      return 6;\n    }\n  };\n  var measureEBMLVarInt = (value) => {\n    if (value < (1 << 7) - 1) {\n      return 1;\n    } else if (value < (1 << 14) - 1) {\n      return 2;\n    } else if (value < (1 << 21) - 1) {\n      return 3;\n    } else if (value < (1 << 28) - 1) {\n      return 4;\n    } else if (value < 2 ** 35 - 1) {\n      return 5;\n    } else if (value < 2 ** 42 - 1) {\n      return 6;\n    } else {\n      throw new Error(\"EBML VINT size not supported \" + value);\n    }\n  };\n\n  // src/misc.ts\n  var readBits = (bytes, start, end) => {\n    let result = 0;\n    for (let i = start; i < end; i++) {\n      let byteIndex = Math.floor(i / 8);\n      let byte = bytes[byteIndex];\n      let bitIndex = 7 - (i & 7);\n      let bit = (byte & 1 << bitIndex) >> bitIndex;\n      result <<= 1;\n      result |= bit;\n    }\n    return result;\n  };\n  var writeBits = (bytes, start, end, value) => {\n    for (let i = start; i < end; i++) {\n      let byteIndex = Math.floor(i / 8);\n      let byte = bytes[byteIndex];\n      let bitIndex = 7 - (i & 7);\n      byte &= ~(1 << bitIndex);\n      byte |= (value & 1 << end - i - 1) >> end - i - 1 << bitIndex;\n      bytes[byteIndex] = byte;\n    }\n  };\n\n  // src/target.ts\n  var isTarget = Symbol(\"isTarget\");\n  var Target = class {\n  };\n  isTarget;\n  var ArrayBufferTarget = class extends Target {\n    constructor() {\n      super(...arguments);\n      this.buffer = null;\n    }\n  };\n  var StreamTarget = class extends Target {\n    constructor(options) {\n      super();\n      this.options = options;\n      if (typeof options !== \"object\") {\n        throw new TypeError(\"StreamTarget requires an options object to be passed to its constructor.\");\n      }\n      if (options.onData) {\n        if (typeof options.onData !== \"function\") {\n          throw new TypeError(\"options.onData, when provided, must be a function.\");\n        }\n        if (options.onData.length < 2) {\n          throw new TypeError(\n            \"options.onData, when provided, must be a function that takes in at least two arguments (data and position). Ignoring the position argument, which specifies the byte offset at which the data is to be written, can lead to broken outputs.\"\n          );\n        }\n      }\n      if (options.onHeader && typeof options.onHeader !== \"function\") {\n        throw new TypeError(\"options.onHeader, when provided, must be a function.\");\n      }\n      if (options.onCluster && typeof options.onCluster !== \"function\") {\n        throw new TypeError(\"options.onCluster, when provided, must be a function.\");\n      }\n      if (options.chunked !== void 0 && typeof options.chunked !== \"boolean\") {\n        throw new TypeError(\"options.chunked, when provided, must be a boolean.\");\n      }\n      if (options.chunkSize !== void 0 && (!Number.isInteger(options.chunkSize) || options.chunkSize <= 0)) {\n        throw new TypeError(\"options.chunkSize, when provided, must be a positive integer.\");\n      }\n    }\n  };\n  var FileSystemWritableFileStreamTarget = class extends Target {\n    constructor(stream, options) {\n      super();\n      this.stream = stream;\n      this.options = options;\n      if (!(stream instanceof FileSystemWritableFileStream)) {\n        throw new TypeError(\"FileSystemWritableFileStreamTarget requires a FileSystemWritableFileStream instance.\");\n      }\n      if (options !== void 0 && typeof options !== \"object\") {\n        throw new TypeError(\"FileSystemWritableFileStreamTarget's options, when provided, must be an object.\");\n      }\n      if (options) {\n        if (options.chunkSize !== void 0 && (!Number.isInteger(options.chunkSize) || options.chunkSize <= 0)) {\n          throw new TypeError(\"options.chunkSize, when provided, must be a positive integer\");\n        }\n      }\n    }\n  };\n\n  // src/writer.ts\n  var _helper, _helperView, _writeByte, writeByte_fn, _writeFloat32, writeFloat32_fn, _writeFloat64, writeFloat64_fn, _writeUnsignedInt, writeUnsignedInt_fn, _writeString, writeString_fn;\n  var Writer = class {\n    constructor() {\n      __privateAdd(this, _writeByte);\n      __privateAdd(this, _writeFloat32);\n      __privateAdd(this, _writeFloat64);\n      __privateAdd(this, _writeUnsignedInt);\n      __privateAdd(this, _writeString);\n      this.pos = 0;\n      __privateAdd(this, _helper, new Uint8Array(8));\n      __privateAdd(this, _helperView, new DataView(__privateGet(this, _helper).buffer));\n      this.offsets = /* @__PURE__ */ new WeakMap();\n      this.dataOffsets = /* @__PURE__ */ new WeakMap();\n    }\n    seek(newPos) {\n      this.pos = newPos;\n    }\n    writeEBMLVarInt(value, width = measureEBMLVarInt(value)) {\n      let pos = 0;\n      switch (width) {\n        case 1:\n          __privateGet(this, _helperView).setUint8(pos++, 1 << 7 | value);\n          break;\n        case 2:\n          __privateGet(this, _helperView).setUint8(pos++, 1 << 6 | value >> 8);\n          __privateGet(this, _helperView).setUint8(pos++, value);\n          break;\n        case 3:\n          __privateGet(this, _helperView).setUint8(pos++, 1 << 5 | value >> 16);\n          __privateGet(this, _helperView).setUint8(pos++, value >> 8);\n          __privateGet(this, _helperView).setUint8(pos++, value);\n          break;\n        case 4:\n          __privateGet(this, _helperView).setUint8(pos++, 1 << 4 | value >> 24);\n          __privateGet(this, _helperView).setUint8(pos++, value >> 16);\n          __privateGet(this, _helperView).setUint8(pos++, value >> 8);\n          __privateGet(this, _helperView).setUint8(pos++, value);\n          break;\n        case 5:\n          __privateGet(this, _helperView).setUint8(pos++, 1 << 3 | value / 2 ** 32 & 7);\n          __privateGet(this, _helperView).setUint8(pos++, value >> 24);\n          __privateGet(this, _helperView).setUint8(pos++, value >> 16);\n          __privateGet(this, _helperView).setUint8(pos++, value >> 8);\n          __privateGet(this, _helperView).setUint8(pos++, value);\n          break;\n        case 6:\n          __privateGet(this, _helperView).setUint8(pos++, 1 << 2 | value / 2 ** 40 & 3);\n          __privateGet(this, _helperView).setUint8(pos++, value / 2 ** 32 | 0);\n          __privateGet(this, _helperView).setUint8(pos++, value >> 24);\n          __privateGet(this, _helperView).setUint8(pos++, value >> 16);\n          __privateGet(this, _helperView).setUint8(pos++, value >> 8);\n          __privateGet(this, _helperView).setUint8(pos++, value);\n          break;\n        default:\n          throw new Error(\"Bad EBML VINT size \" + width);\n      }\n      this.write(__privateGet(this, _helper).subarray(0, pos));\n    }\n    writeEBML(data) {\n      if (data === null)\n        return;\n      if (data instanceof Uint8Array) {\n        this.write(data);\n      } else if (Array.isArray(data)) {\n        for (let elem of data) {\n          this.writeEBML(elem);\n        }\n      } else {\n        this.offsets.set(data, this.pos);\n        __privateMethod(this, _writeUnsignedInt, writeUnsignedInt_fn).call(this, data.id);\n        if (Array.isArray(data.data)) {\n          let sizePos = this.pos;\n          let sizeSize = data.size === -1 ? 1 : data.size ?? 4;\n          if (data.size === -1) {\n            __privateMethod(this, _writeByte, writeByte_fn).call(this, 255);\n          } else {\n            this.seek(this.pos + sizeSize);\n          }\n          let startPos = this.pos;\n          this.dataOffsets.set(data, startPos);\n          this.writeEBML(data.data);\n          if (data.size !== -1) {\n            let size = this.pos - startPos;\n            let endPos = this.pos;\n            this.seek(sizePos);\n            this.writeEBMLVarInt(size, sizeSize);\n            this.seek(endPos);\n          }\n        } else if (typeof data.data === \"number\") {\n          let size = data.size ?? measureUnsignedInt(data.data);\n          this.writeEBMLVarInt(size);\n          __privateMethod(this, _writeUnsignedInt, writeUnsignedInt_fn).call(this, data.data, size);\n        } else if (typeof data.data === \"string\") {\n          this.writeEBMLVarInt(data.data.length);\n          __privateMethod(this, _writeString, writeString_fn).call(this, data.data);\n        } else if (data.data instanceof Uint8Array) {\n          this.writeEBMLVarInt(data.data.byteLength, data.size);\n          this.write(data.data);\n        } else if (data.data instanceof EBMLFloat32) {\n          this.writeEBMLVarInt(4);\n          __privateMethod(this, _writeFloat32, writeFloat32_fn).call(this, data.data.value);\n        } else if (data.data instanceof EBMLFloat64) {\n          this.writeEBMLVarInt(8);\n          __privateMethod(this, _writeFloat64, writeFloat64_fn).call(this, data.data.value);\n        }\n      }\n    }\n  };\n  _helper = new WeakMap();\n  _helperView = new WeakMap();\n  _writeByte = new WeakSet();\n  writeByte_fn = function(value) {\n    __privateGet(this, _helperView).setUint8(0, value);\n    this.write(__privateGet(this, _helper).subarray(0, 1));\n  };\n  _writeFloat32 = new WeakSet();\n  writeFloat32_fn = function(value) {\n    __privateGet(this, _helperView).setFloat32(0, value, false);\n    this.write(__privateGet(this, _helper).subarray(0, 4));\n  };\n  _writeFloat64 = new WeakSet();\n  writeFloat64_fn = function(value) {\n    __privateGet(this, _helperView).setFloat64(0, value, false);\n    this.write(__privateGet(this, _helper));\n  };\n  _writeUnsignedInt = new WeakSet();\n  writeUnsignedInt_fn = function(value, width = measureUnsignedInt(value)) {\n    let pos = 0;\n    switch (width) {\n      case 6:\n        __privateGet(this, _helperView).setUint8(pos++, value / 2 ** 40 | 0);\n      case 5:\n        __privateGet(this, _helperView).setUint8(pos++, value / 2 ** 32 | 0);\n      case 4:\n        __privateGet(this, _helperView).setUint8(pos++, value >> 24);\n      case 3:\n        __privateGet(this, _helperView).setUint8(pos++, value >> 16);\n      case 2:\n        __privateGet(this, _helperView).setUint8(pos++, value >> 8);\n      case 1:\n        __privateGet(this, _helperView).setUint8(pos++, value);\n        break;\n      default:\n        throw new Error(\"Bad UINT size \" + width);\n    }\n    this.write(__privateGet(this, _helper).subarray(0, pos));\n  };\n  _writeString = new WeakSet();\n  writeString_fn = function(str) {\n    this.write(new Uint8Array(str.split(\"\").map((x) => x.charCodeAt(0))));\n  };\n  var _target, _buffer, _bytes, _ensureSize, ensureSize_fn;\n  var ArrayBufferTargetWriter = class extends Writer {\n    constructor(target) {\n      super();\n      __privateAdd(this, _ensureSize);\n      __privateAdd(this, _target, void 0);\n      __privateAdd(this, _buffer, new ArrayBuffer(2 ** 16));\n      __privateAdd(this, _bytes, new Uint8Array(__privateGet(this, _buffer)));\n      __privateSet(this, _target, target);\n    }\n    write(data) {\n      __privateMethod(this, _ensureSize, ensureSize_fn).call(this, this.pos + data.byteLength);\n      __privateGet(this, _bytes).set(data, this.pos);\n      this.pos += data.byteLength;\n    }\n    finalize() {\n      __privateMethod(this, _ensureSize, ensureSize_fn).call(this, this.pos);\n      __privateGet(this, _target).buffer = __privateGet(this, _buffer).slice(0, this.pos);\n    }\n  };\n  _target = new WeakMap();\n  _buffer = new WeakMap();\n  _bytes = new WeakMap();\n  _ensureSize = new WeakSet();\n  ensureSize_fn = function(size) {\n    let newLength = __privateGet(this, _buffer).byteLength;\n    while (newLength < size)\n      newLength *= 2;\n    if (newLength === __privateGet(this, _buffer).byteLength)\n      return;\n    let newBuffer = new ArrayBuffer(newLength);\n    let newBytes = new Uint8Array(newBuffer);\n    newBytes.set(__privateGet(this, _bytes), 0);\n    __privateSet(this, _buffer, newBuffer);\n    __privateSet(this, _bytes, newBytes);\n  };\n  var _trackingWrites, _trackedWrites, _trackedStart, _trackedEnd;\n  var BaseStreamTargetWriter = class extends Writer {\n    constructor(target) {\n      super();\n      this.target = target;\n      __privateAdd(this, _trackingWrites, false);\n      __privateAdd(this, _trackedWrites, void 0);\n      __privateAdd(this, _trackedStart, void 0);\n      __privateAdd(this, _trackedEnd, void 0);\n    }\n    write(data) {\n      if (!__privateGet(this, _trackingWrites))\n        return;\n      let pos = this.pos;\n      if (pos < __privateGet(this, _trackedStart)) {\n        if (pos + data.byteLength <= __privateGet(this, _trackedStart))\n          return;\n        data = data.subarray(__privateGet(this, _trackedStart) - pos);\n        pos = 0;\n      }\n      let neededSize = pos + data.byteLength - __privateGet(this, _trackedStart);\n      let newLength = __privateGet(this, _trackedWrites).byteLength;\n      while (newLength < neededSize)\n        newLength *= 2;\n      if (newLength !== __privateGet(this, _trackedWrites).byteLength) {\n        let copy = new Uint8Array(newLength);\n        copy.set(__privateGet(this, _trackedWrites), 0);\n        __privateSet(this, _trackedWrites, copy);\n      }\n      __privateGet(this, _trackedWrites).set(data, pos - __privateGet(this, _trackedStart));\n      __privateSet(this, _trackedEnd, Math.max(__privateGet(this, _trackedEnd), pos + data.byteLength));\n    }\n    startTrackingWrites() {\n      __privateSet(this, _trackingWrites, true);\n      __privateSet(this, _trackedWrites, new Uint8Array(2 ** 10));\n      __privateSet(this, _trackedStart, this.pos);\n      __privateSet(this, _trackedEnd, this.pos);\n    }\n    getTrackedWrites() {\n      if (!__privateGet(this, _trackingWrites)) {\n        throw new Error(\"Can't get tracked writes since nothing was tracked.\");\n      }\n      let slice = __privateGet(this, _trackedWrites).subarray(0, __privateGet(this, _trackedEnd) - __privateGet(this, _trackedStart));\n      let result = {\n        data: slice,\n        start: __privateGet(this, _trackedStart),\n        end: __privateGet(this, _trackedEnd)\n      };\n      __privateSet(this, _trackedWrites, void 0);\n      __privateSet(this, _trackingWrites, false);\n      return result;\n    }\n  };\n  _trackingWrites = new WeakMap();\n  _trackedWrites = new WeakMap();\n  _trackedStart = new WeakMap();\n  _trackedEnd = new WeakMap();\n  var _sections, _lastFlushEnd, _ensureMonotonicity;\n  var StreamTargetWriter = class extends BaseStreamTargetWriter {\n    constructor(target, ensureMonotonicity) {\n      super(target);\n      __privateAdd(this, _sections, []);\n      __privateAdd(this, _lastFlushEnd, 0);\n      __privateAdd(this, _ensureMonotonicity, void 0);\n      __privateSet(this, _ensureMonotonicity, ensureMonotonicity);\n    }\n    write(data) {\n      super.write(data);\n      __privateGet(this, _sections).push({\n        data: data.slice(),\n        start: this.pos\n      });\n      this.pos += data.byteLength;\n    }\n    flush() {\n      if (__privateGet(this, _sections).length === 0)\n        return;\n      let chunks = [];\n      let sorted = [...__privateGet(this, _sections)].sort((a, b) => a.start - b.start);\n      chunks.push({\n        start: sorted[0].start,\n        size: sorted[0].data.byteLength\n      });\n      for (let i = 1; i < sorted.length; i++) {\n        let lastChunk = chunks[chunks.length - 1];\n        let section = sorted[i];\n        if (section.start <= lastChunk.start + lastChunk.size) {\n          lastChunk.size = Math.max(lastChunk.size, section.start + section.data.byteLength - lastChunk.start);\n        } else {\n          chunks.push({\n            start: section.start,\n            size: section.data.byteLength\n          });\n        }\n      }\n      for (let chunk of chunks) {\n        chunk.data = new Uint8Array(chunk.size);\n        for (let section of __privateGet(this, _sections)) {\n          if (chunk.start <= section.start && section.start < chunk.start + chunk.size) {\n            chunk.data.set(section.data, section.start - chunk.start);\n          }\n        }\n        if (__privateGet(this, _ensureMonotonicity) && chunk.start < __privateGet(this, _lastFlushEnd)) {\n          throw new Error(\"Internal error: Monotonicity violation.\");\n        }\n        this.target.options.onData?.(chunk.data, chunk.start);\n        __privateSet(this, _lastFlushEnd, chunk.start + chunk.data.byteLength);\n      }\n      __privateGet(this, _sections).length = 0;\n    }\n    finalize() {\n    }\n  };\n  _sections = new WeakMap();\n  _lastFlushEnd = new WeakMap();\n  _ensureMonotonicity = new WeakMap();\n  var DEFAULT_CHUNK_SIZE = 2 ** 24;\n  var MAX_CHUNKS_AT_ONCE = 2;\n  var _chunkSize, _chunks, _lastFlushEnd2, _ensureMonotonicity2, _writeDataIntoChunks, writeDataIntoChunks_fn, _insertSectionIntoChunk, insertSectionIntoChunk_fn, _createChunk, createChunk_fn, _flushChunks, flushChunks_fn;\n  var ChunkedStreamTargetWriter = class extends BaseStreamTargetWriter {\n    constructor(target, ensureMonotonicity) {\n      super(target);\n      __privateAdd(this, _writeDataIntoChunks);\n      __privateAdd(this, _insertSectionIntoChunk);\n      __privateAdd(this, _createChunk);\n      __privateAdd(this, _flushChunks);\n      __privateAdd(this, _chunkSize, void 0);\n      __privateAdd(this, _chunks, []);\n      __privateAdd(this, _lastFlushEnd2, 0);\n      __privateAdd(this, _ensureMonotonicity2, void 0);\n      __privateSet(this, _chunkSize, target.options?.chunkSize ?? DEFAULT_CHUNK_SIZE);\n      __privateSet(this, _ensureMonotonicity2, ensureMonotonicity);\n      if (!Number.isInteger(__privateGet(this, _chunkSize)) || __privateGet(this, _chunkSize) < 2 ** 10) {\n        throw new Error(\"Invalid StreamTarget options: chunkSize must be an integer not smaller than 1024.\");\n      }\n    }\n    write(data) {\n      super.write(data);\n      __privateMethod(this, _writeDataIntoChunks, writeDataIntoChunks_fn).call(this, data, this.pos);\n      __privateMethod(this, _flushChunks, flushChunks_fn).call(this);\n      this.pos += data.byteLength;\n    }\n    finalize() {\n      __privateMethod(this, _flushChunks, flushChunks_fn).call(this, true);\n    }\n  };\n  _chunkSize = new WeakMap();\n  _chunks = new WeakMap();\n  _lastFlushEnd2 = new WeakMap();\n  _ensureMonotonicity2 = new WeakMap();\n  _writeDataIntoChunks = new WeakSet();\n  writeDataIntoChunks_fn = function(data, position) {\n    let chunkIndex = __privateGet(this, _chunks).findIndex((x) => x.start <= position && position < x.start + __privateGet(this, _chunkSize));\n    if (chunkIndex === -1)\n      chunkIndex = __privateMethod(this, _createChunk, createChunk_fn).call(this, position);\n    let chunk = __privateGet(this, _chunks)[chunkIndex];\n    let relativePosition = position - chunk.start;\n    let toWrite = data.subarray(0, Math.min(__privateGet(this, _chunkSize) - relativePosition, data.byteLength));\n    chunk.data.set(toWrite, relativePosition);\n    let section = {\n      start: relativePosition,\n      end: relativePosition + toWrite.byteLength\n    };\n    __privateMethod(this, _insertSectionIntoChunk, insertSectionIntoChunk_fn).call(this, chunk, section);\n    if (chunk.written[0].start === 0 && chunk.written[0].end === __privateGet(this, _chunkSize)) {\n      chunk.shouldFlush = true;\n    }\n    if (__privateGet(this, _chunks).length > MAX_CHUNKS_AT_ONCE) {\n      for (let i = 0; i < __privateGet(this, _chunks).length - 1; i++) {\n        __privateGet(this, _chunks)[i].shouldFlush = true;\n      }\n      __privateMethod(this, _flushChunks, flushChunks_fn).call(this);\n    }\n    if (toWrite.byteLength < data.byteLength) {\n      __privateMethod(this, _writeDataIntoChunks, writeDataIntoChunks_fn).call(this, data.subarray(toWrite.byteLength), position + toWrite.byteLength);\n    }\n  };\n  _insertSectionIntoChunk = new WeakSet();\n  insertSectionIntoChunk_fn = function(chunk, section) {\n    let low = 0;\n    let high = chunk.written.length - 1;\n    let index = -1;\n    while (low <= high) {\n      let mid = Math.floor(low + (high - low + 1) / 2);\n      if (chunk.written[mid].start <= section.start) {\n        low = mid + 1;\n        index = mid;\n      } else {\n        high = mid - 1;\n      }\n    }\n    chunk.written.splice(index + 1, 0, section);\n    if (index === -1 || chunk.written[index].end < section.start)\n      index++;\n    while (index < chunk.written.length - 1 && chunk.written[index].end >= chunk.written[index + 1].start) {\n      chunk.written[index].end = Math.max(chunk.written[index].end, chunk.written[index + 1].end);\n      chunk.written.splice(index + 1, 1);\n    }\n  };\n  _createChunk = new WeakSet();\n  createChunk_fn = function(includesPosition) {\n    let start = Math.floor(includesPosition / __privateGet(this, _chunkSize)) * __privateGet(this, _chunkSize);\n    let chunk = {\n      start,\n      data: new Uint8Array(__privateGet(this, _chunkSize)),\n      written: [],\n      shouldFlush: false\n    };\n    __privateGet(this, _chunks).push(chunk);\n    __privateGet(this, _chunks).sort((a, b) => a.start - b.start);\n    return __privateGet(this, _chunks).indexOf(chunk);\n  };\n  _flushChunks = new WeakSet();\n  flushChunks_fn = function(force = false) {\n    for (let i = 0; i < __privateGet(this, _chunks).length; i++) {\n      let chunk = __privateGet(this, _chunks)[i];\n      if (!chunk.shouldFlush && !force)\n        continue;\n      for (let section of chunk.written) {\n        if (__privateGet(this, _ensureMonotonicity2) && chunk.start + section.start < __privateGet(this, _lastFlushEnd2)) {\n          throw new Error(\"Internal error: Monotonicity violation.\");\n        }\n        this.target.options.onData?.(\n          chunk.data.subarray(section.start, section.end),\n          chunk.start + section.start\n        );\n        __privateSet(this, _lastFlushEnd2, chunk.start + section.end);\n      }\n      __privateGet(this, _chunks).splice(i--, 1);\n    }\n  };\n  var FileSystemWritableFileStreamTargetWriter = class extends ChunkedStreamTargetWriter {\n    constructor(target, ensureMonotonicity) {\n      super(new StreamTarget({\n        onData: (data, position) => target.stream.write({\n          type: \"write\",\n          data,\n          position\n        }),\n        chunked: true,\n        chunkSize: target.options?.chunkSize\n      }), ensureMonotonicity);\n    }\n  };\n\n  // src/muxer.ts\n  var VIDEO_TRACK_NUMBER = 1;\n  var AUDIO_TRACK_NUMBER = 2;\n  var SUBTITLE_TRACK_NUMBER = 3;\n  var VIDEO_TRACK_TYPE = 1;\n  var AUDIO_TRACK_TYPE = 2;\n  var SUBTITLE_TRACK_TYPE = 17;\n  var MAX_CHUNK_LENGTH_MS = 2 ** 15;\n  var CODEC_PRIVATE_MAX_SIZE = 2 ** 12;\n  var APP_NAME = \"https://github.com/Vanilagy/webm-muxer\";\n  var SEGMENT_SIZE_BYTES = 6;\n  var CLUSTER_SIZE_BYTES = 5;\n  var FIRST_TIMESTAMP_BEHAVIORS = [\"strict\", \"offset\", \"permissive\"];\n  var _options, _writer, _segment, _segmentInfo, _seekHead, _tracksElement, _segmentDuration, _colourElement, _videoCodecPrivate, _audioCodecPrivate, _subtitleCodecPrivate, _cues, _currentCluster, _currentClusterTimestamp, _duration, _videoChunkQueue, _audioChunkQueue, _subtitleChunkQueue, _firstVideoTimestamp, _firstAudioTimestamp, _lastVideoTimestamp, _lastAudioTimestamp, _lastSubtitleTimestamp, _colorSpace, _finalized, _validateOptions, validateOptions_fn, _createFileHeader, createFileHeader_fn, _writeEBMLHeader, writeEBMLHeader_fn, _createCodecPrivatePlaceholders, createCodecPrivatePlaceholders_fn, _createColourElement, createColourElement_fn, _createSeekHead, createSeekHead_fn, _createSegmentInfo, createSegmentInfo_fn, _createTracks, createTracks_fn, _createSegment, createSegment_fn, _createCues, createCues_fn, _maybeFlushStreamingTargetWriter, maybeFlushStreamingTargetWriter_fn, _segmentDataOffset, segmentDataOffset_get, _writeVideoDecoderConfig, writeVideoDecoderConfig_fn, _fixVP9ColorSpace, fixVP9ColorSpace_fn, _writeSubtitleChunks, writeSubtitleChunks_fn, _createInternalChunk, createInternalChunk_fn, _validateTimestamp, validateTimestamp_fn, _writeBlock, writeBlock_fn, _createCodecPrivateElement, createCodecPrivateElement_fn, _writeCodecPrivate, writeCodecPrivate_fn, _createNewCluster, createNewCluster_fn, _finalizeCurrentCluster, finalizeCurrentCluster_fn, _ensureNotFinalized, ensureNotFinalized_fn;\n  var Muxer = class {\n    constructor(options) {\n      __privateAdd(this, _validateOptions);\n      __privateAdd(this, _createFileHeader);\n      __privateAdd(this, _writeEBMLHeader);\n      __privateAdd(this, _createCodecPrivatePlaceholders);\n      __privateAdd(this, _createColourElement);\n      __privateAdd(this, _createSeekHead);\n      __privateAdd(this, _createSegmentInfo);\n      __privateAdd(this, _createTracks);\n      __privateAdd(this, _createSegment);\n      __privateAdd(this, _createCues);\n      __privateAdd(this, _maybeFlushStreamingTargetWriter);\n      __privateAdd(this, _segmentDataOffset);\n      __privateAdd(this, _writeVideoDecoderConfig);\n      __privateAdd(this, _fixVP9ColorSpace);\n      __privateAdd(this, _writeSubtitleChunks);\n      __privateAdd(this, _createInternalChunk);\n      __privateAdd(this, _validateTimestamp);\n      __privateAdd(this, _writeBlock);\n      __privateAdd(this, _createCodecPrivateElement);\n      __privateAdd(this, _writeCodecPrivate);\n      __privateAdd(this, _createNewCluster);\n      __privateAdd(this, _finalizeCurrentCluster);\n      __privateAdd(this, _ensureNotFinalized);\n      __privateAdd(this, _options, void 0);\n      __privateAdd(this, _writer, void 0);\n      __privateAdd(this, _segment, void 0);\n      __privateAdd(this, _segmentInfo, void 0);\n      __privateAdd(this, _seekHead, void 0);\n      __privateAdd(this, _tracksElement, void 0);\n      __privateAdd(this, _segmentDuration, void 0);\n      __privateAdd(this, _colourElement, void 0);\n      __privateAdd(this, _videoCodecPrivate, void 0);\n      __privateAdd(this, _audioCodecPrivate, void 0);\n      __privateAdd(this, _subtitleCodecPrivate, void 0);\n      __privateAdd(this, _cues, void 0);\n      __privateAdd(this, _currentCluster, void 0);\n      __privateAdd(this, _currentClusterTimestamp, void 0);\n      __privateAdd(this, _duration, 0);\n      __privateAdd(this, _videoChunkQueue, []);\n      __privateAdd(this, _audioChunkQueue, []);\n      __privateAdd(this, _subtitleChunkQueue, []);\n      __privateAdd(this, _firstVideoTimestamp, void 0);\n      __privateAdd(this, _firstAudioTimestamp, void 0);\n      __privateAdd(this, _lastVideoTimestamp, -1);\n      __privateAdd(this, _lastAudioTimestamp, -1);\n      __privateAdd(this, _lastSubtitleTimestamp, -1);\n      __privateAdd(this, _colorSpace, void 0);\n      __privateAdd(this, _finalized, false);\n      __privateMethod(this, _validateOptions, validateOptions_fn).call(this, options);\n      __privateSet(this, _options, {\n        type: \"webm\",\n        firstTimestampBehavior: \"strict\",\n        ...options\n      });\n      this.target = options.target;\n      let ensureMonotonicity = !!__privateGet(this, _options).streaming;\n      if (options.target instanceof ArrayBufferTarget) {\n        __privateSet(this, _writer, new ArrayBufferTargetWriter(options.target));\n      } else if (options.target instanceof StreamTarget) {\n        __privateSet(this, _writer, options.target.options?.chunked ? new ChunkedStreamTargetWriter(options.target, ensureMonotonicity) : new StreamTargetWriter(options.target, ensureMonotonicity));\n      } else if (options.target instanceof FileSystemWritableFileStreamTarget) {\n        __privateSet(this, _writer, new FileSystemWritableFileStreamTargetWriter(options.target, ensureMonotonicity));\n      } else {\n        throw new Error(`Invalid target: ${options.target}`);\n      }\n      __privateMethod(this, _createFileHeader, createFileHeader_fn).call(this);\n    }\n    addVideoChunk(chunk, meta, timestamp) {\n      if (!(chunk instanceof EncodedVideoChunk)) {\n        throw new TypeError(\"addVideoChunk's first argument (chunk) must be of type EncodedVideoChunk.\");\n      }\n      if (meta && typeof meta !== \"object\") {\n        throw new TypeError(\"addVideoChunk's second argument (meta), when provided, must be an object.\");\n      }\n      if (timestamp !== void 0 && (!Number.isFinite(timestamp) || timestamp < 0)) {\n        throw new TypeError(\n          \"addVideoChunk's third argument (timestamp), when provided, must be a non-negative real number.\"\n        );\n      }\n      let data = new Uint8Array(chunk.byteLength);\n      chunk.copyTo(data);\n      this.addVideoChunkRaw(data, chunk.type, timestamp ?? chunk.timestamp, meta);\n    }\n    addVideoChunkRaw(data, type, timestamp, meta) {\n      if (!(data instanceof Uint8Array)) {\n        throw new TypeError(\"addVideoChunkRaw's first argument (data) must be an instance of Uint8Array.\");\n      }\n      if (type !== \"key\" && type !== \"delta\") {\n        throw new TypeError(\"addVideoChunkRaw's second argument (type) must be either 'key' or 'delta'.\");\n      }\n      if (!Number.isFinite(timestamp) || timestamp < 0) {\n        throw new TypeError(\"addVideoChunkRaw's third argument (timestamp) must be a non-negative real number.\");\n      }\n      if (meta && typeof meta !== \"object\") {\n        throw new TypeError(\"addVideoChunkRaw's fourth argument (meta), when provided, must be an object.\");\n      }\n      __privateMethod(this, _ensureNotFinalized, ensureNotFinalized_fn).call(this);\n      if (!__privateGet(this, _options).video)\n        throw new Error(\"No video track declared.\");\n      if (__privateGet(this, _firstVideoTimestamp) === void 0)\n        __privateSet(this, _firstVideoTimestamp, timestamp);\n      if (meta)\n        __privateMethod(this, _writeVideoDecoderConfig, writeVideoDecoderConfig_fn).call(this, meta);\n      let videoChunk = __privateMethod(this, _createInternalChunk, createInternalChunk_fn).call(this, data, type, timestamp, VIDEO_TRACK_NUMBER);\n      if (__privateGet(this, _options).video.codec === \"V_VP9\")\n        __privateMethod(this, _fixVP9ColorSpace, fixVP9ColorSpace_fn).call(this, videoChunk);\n      __privateSet(this, _lastVideoTimestamp, videoChunk.timestamp);\n      while (__privateGet(this, _audioChunkQueue).length > 0 && __privateGet(this, _audioChunkQueue)[0].timestamp <= videoChunk.timestamp) {\n        let audioChunk = __privateGet(this, _audioChunkQueue).shift();\n        __privateMethod(this, _writeBlock, writeBlock_fn).call(this, audioChunk, false);\n      }\n      if (!__privateGet(this, _options).audio || videoChunk.timestamp <= __privateGet(this, _lastAudioTimestamp)) {\n        __privateMethod(this, _writeBlock, writeBlock_fn).call(this, videoChunk, true);\n      } else {\n        __privateGet(this, _videoChunkQueue).push(videoChunk);\n      }\n      __privateMethod(this, _writeSubtitleChunks, writeSubtitleChunks_fn).call(this);\n      __privateMethod(this, _maybeFlushStreamingTargetWriter, maybeFlushStreamingTargetWriter_fn).call(this);\n    }\n    addAudioChunk(chunk, meta, timestamp) {\n      if (!(chunk instanceof EncodedAudioChunk)) {\n        throw new TypeError(\"addAudioChunk's first argument (chunk) must be of type EncodedAudioChunk.\");\n      }\n      if (meta && typeof meta !== \"object\") {\n        throw new TypeError(\"addAudioChunk's second argument (meta), when provided, must be an object.\");\n      }\n      if (timestamp !== void 0 && (!Number.isFinite(timestamp) || timestamp < 0)) {\n        throw new TypeError(\n          \"addAudioChunk's third argument (timestamp), when provided, must be a non-negative real number.\"\n        );\n      }\n      let data = new Uint8Array(chunk.byteLength);\n      chunk.copyTo(data);\n      this.addAudioChunkRaw(data, chunk.type, timestamp ?? chunk.timestamp, meta);\n    }\n    addAudioChunkRaw(data, type, timestamp, meta) {\n      if (!(data instanceof Uint8Array)) {\n        throw new TypeError(\"addAudioChunkRaw's first argument (data) must be an instance of Uint8Array.\");\n      }\n      if (type !== \"key\" && type !== \"delta\") {\n        throw new TypeError(\"addAudioChunkRaw's second argument (type) must be either 'key' or 'delta'.\");\n      }\n      if (!Number.isFinite(timestamp) || timestamp < 0) {\n        throw new TypeError(\"addAudioChunkRaw's third argument (timestamp) must be a non-negative real number.\");\n      }\n      if (meta && typeof meta !== \"object\") {\n        throw new TypeError(\"addAudioChunkRaw's fourth argument (meta), when provided, must be an object.\");\n      }\n      __privateMethod(this, _ensureNotFinalized, ensureNotFinalized_fn).call(this);\n      if (!__privateGet(this, _options).audio)\n        throw new Error(\"No audio track declared.\");\n      if (__privateGet(this, _firstAudioTimestamp) === void 0)\n        __privateSet(this, _firstAudioTimestamp, timestamp);\n      if (meta?.decoderConfig) {\n        if (__privateGet(this, _options).streaming) {\n          __privateSet(this, _audioCodecPrivate, __privateMethod(this, _createCodecPrivateElement, createCodecPrivateElement_fn).call(this, meta.decoderConfig.description));\n        } else {\n          __privateMethod(this, _writeCodecPrivate, writeCodecPrivate_fn).call(this, __privateGet(this, _audioCodecPrivate), meta.decoderConfig.description);\n        }\n      }\n      let audioChunk = __privateMethod(this, _createInternalChunk, createInternalChunk_fn).call(this, data, type, timestamp, AUDIO_TRACK_NUMBER);\n      __privateSet(this, _lastAudioTimestamp, audioChunk.timestamp);\n      while (__privateGet(this, _videoChunkQueue).length > 0 && __privateGet(this, _videoChunkQueue)[0].timestamp <= audioChunk.timestamp) {\n        let videoChunk = __privateGet(this, _videoChunkQueue).shift();\n        __privateMethod(this, _writeBlock, writeBlock_fn).call(this, videoChunk, true);\n      }\n      if (!__privateGet(this, _options).video || audioChunk.timestamp <= __privateGet(this, _lastVideoTimestamp)) {\n        __privateMethod(this, _writeBlock, writeBlock_fn).call(this, audioChunk, !__privateGet(this, _options).video);\n      } else {\n        __privateGet(this, _audioChunkQueue).push(audioChunk);\n      }\n      __privateMethod(this, _writeSubtitleChunks, writeSubtitleChunks_fn).call(this);\n      __privateMethod(this, _maybeFlushStreamingTargetWriter, maybeFlushStreamingTargetWriter_fn).call(this);\n    }\n    addSubtitleChunk(chunk, meta, timestamp) {\n      if (typeof chunk !== \"object\" || !chunk) {\n        throw new TypeError(\"addSubtitleChunk's first argument (chunk) must be an object.\");\n      } else {\n        if (!(chunk.body instanceof Uint8Array)) {\n          throw new TypeError(\"body must be an instance of Uint8Array.\");\n        }\n        if (!Number.isFinite(chunk.timestamp) || chunk.timestamp < 0) {\n          throw new TypeError(\"timestamp must be a non-negative real number.\");\n        }\n        if (!Number.isFinite(chunk.duration) || chunk.duration < 0) {\n          throw new TypeError(\"duration must be a non-negative real number.\");\n        }\n        if (chunk.additions && !(chunk.additions instanceof Uint8Array)) {\n          throw new TypeError(\"additions, when present, must be an instance of Uint8Array.\");\n        }\n      }\n      if (typeof meta !== \"object\") {\n        throw new TypeError(\"addSubtitleChunk's second argument (meta) must be an object.\");\n      }\n      __privateMethod(this, _ensureNotFinalized, ensureNotFinalized_fn).call(this);\n      if (!__privateGet(this, _options).subtitles)\n        throw new Error(\"No subtitle track declared.\");\n      if (meta?.decoderConfig) {\n        if (__privateGet(this, _options).streaming) {\n          __privateSet(this, _subtitleCodecPrivate, __privateMethod(this, _createCodecPrivateElement, createCodecPrivateElement_fn).call(this, meta.decoderConfig.description));\n        } else {\n          __privateMethod(this, _writeCodecPrivate, writeCodecPrivate_fn).call(this, __privateGet(this, _subtitleCodecPrivate), meta.decoderConfig.description);\n        }\n      }\n      let subtitleChunk = __privateMethod(this, _createInternalChunk, createInternalChunk_fn).call(this, chunk.body, \"key\", timestamp ?? chunk.timestamp, SUBTITLE_TRACK_NUMBER, chunk.duration, chunk.additions);\n      __privateSet(this, _lastSubtitleTimestamp, subtitleChunk.timestamp);\n      __privateGet(this, _subtitleChunkQueue).push(subtitleChunk);\n      __privateMethod(this, _writeSubtitleChunks, writeSubtitleChunks_fn).call(this);\n      __privateMethod(this, _maybeFlushStreamingTargetWriter, maybeFlushStreamingTargetWriter_fn).call(this);\n    }\n    finalize() {\n      if (__privateGet(this, _finalized)) {\n        throw new Error(\"Cannot finalize a muxer more than once.\");\n      }\n      while (__privateGet(this, _videoChunkQueue).length > 0)\n        __privateMethod(this, _writeBlock, writeBlock_fn).call(this, __privateGet(this, _videoChunkQueue).shift(), true);\n      while (__privateGet(this, _audioChunkQueue).length > 0)\n        __privateMethod(this, _writeBlock, writeBlock_fn).call(this, __privateGet(this, _audioChunkQueue).shift(), true);\n      while (__privateGet(this, _subtitleChunkQueue).length > 0 && __privateGet(this, _subtitleChunkQueue)[0].timestamp <= __privateGet(this, _duration)) {\n        __privateMethod(this, _writeBlock, writeBlock_fn).call(this, __privateGet(this, _subtitleChunkQueue).shift(), false);\n      }\n      if (__privateGet(this, _currentCluster) && !__privateGet(this, _options).streaming) {\n        __privateMethod(this, _finalizeCurrentCluster, finalizeCurrentCluster_fn).call(this);\n      }\n      __privateGet(this, _writer).writeEBML(__privateGet(this, _cues));\n      if (!__privateGet(this, _options).streaming) {\n        let endPos = __privateGet(this, _writer).pos;\n        let segmentSize = __privateGet(this, _writer).pos - __privateGet(this, _segmentDataOffset, segmentDataOffset_get);\n        __privateGet(this, _writer).seek(__privateGet(this, _writer).offsets.get(__privateGet(this, _segment)) + 4);\n        __privateGet(this, _writer).writeEBMLVarInt(segmentSize, SEGMENT_SIZE_BYTES);\n        __privateGet(this, _segmentDuration).data = new EBMLFloat64(__privateGet(this, _duration));\n        __privateGet(this, _writer).seek(__privateGet(this, _writer).offsets.get(__privateGet(this, _segmentDuration)));\n        __privateGet(this, _writer).writeEBML(__privateGet(this, _segmentDuration));\n        __privateGet(this, _seekHead).data[0].data[1].data = __privateGet(this, _writer).offsets.get(__privateGet(this, _cues)) - __privateGet(this, _segmentDataOffset, segmentDataOffset_get);\n        __privateGet(this, _seekHead).data[1].data[1].data = __privateGet(this, _writer).offsets.get(__privateGet(this, _segmentInfo)) - __privateGet(this, _segmentDataOffset, segmentDataOffset_get);\n        __privateGet(this, _seekHead).data[2].data[1].data = __privateGet(this, _writer).offsets.get(__privateGet(this, _tracksElement)) - __privateGet(this, _segmentDataOffset, segmentDataOffset_get);\n        __privateGet(this, _writer).seek(__privateGet(this, _writer).offsets.get(__privateGet(this, _seekHead)));\n        __privateGet(this, _writer).writeEBML(__privateGet(this, _seekHead));\n        __privateGet(this, _writer).seek(endPos);\n      }\n      __privateMethod(this, _maybeFlushStreamingTargetWriter, maybeFlushStreamingTargetWriter_fn).call(this);\n      __privateGet(this, _writer).finalize();\n      __privateSet(this, _finalized, true);\n    }\n  };\n  _options = new WeakMap();\n  _writer = new WeakMap();\n  _segment = new WeakMap();\n  _segmentInfo = new WeakMap();\n  _seekHead = new WeakMap();\n  _tracksElement = new WeakMap();\n  _segmentDuration = new WeakMap();\n  _colourElement = new WeakMap();\n  _videoCodecPrivate = new WeakMap();\n  _audioCodecPrivate = new WeakMap();\n  _subtitleCodecPrivate = new WeakMap();\n  _cues = new WeakMap();\n  _currentCluster = new WeakMap();\n  _currentClusterTimestamp = new WeakMap();\n  _duration = new WeakMap();\n  _videoChunkQueue = new WeakMap();\n  _audioChunkQueue = new WeakMap();\n  _subtitleChunkQueue = new WeakMap();\n  _firstVideoTimestamp = new WeakMap();\n  _firstAudioTimestamp = new WeakMap();\n  _lastVideoTimestamp = new WeakMap();\n  _lastAudioTimestamp = new WeakMap();\n  _lastSubtitleTimestamp = new WeakMap();\n  _colorSpace = new WeakMap();\n  _finalized = new WeakMap();\n  _validateOptions = new WeakSet();\n  validateOptions_fn = function(options) {\n    if (typeof options !== \"object\") {\n      throw new TypeError(\"The muxer requires an options object to be passed to its constructor.\");\n    }\n    if (!(options.target instanceof Target)) {\n      throw new TypeError(\"The target must be provided and an instance of Target.\");\n    }\n    if (options.video) {\n      if (typeof options.video.codec !== \"string\") {\n        throw new TypeError(`Invalid video codec: ${options.video.codec}. Must be a string.`);\n      }\n      if (!Number.isInteger(options.video.width) || options.video.width <= 0) {\n        throw new TypeError(`Invalid video width: ${options.video.width}. Must be a positive integer.`);\n      }\n      if (!Number.isInteger(options.video.height) || options.video.height <= 0) {\n        throw new TypeError(`Invalid video height: ${options.video.height}. Must be a positive integer.`);\n      }\n      if (options.video.frameRate !== void 0) {\n        if (!Number.isFinite(options.video.frameRate) || options.video.frameRate <= 0) {\n          throw new TypeError(\n            `Invalid video frame rate: ${options.video.frameRate}. Must be a positive number.`\n          );\n        }\n      }\n      if (options.video.alpha !== void 0 && typeof options.video.alpha !== \"boolean\") {\n        throw new TypeError(`Invalid video alpha: ${options.video.alpha}. Must be a boolean.`);\n      }\n    }\n    if (options.audio) {\n      if (typeof options.audio.codec !== \"string\") {\n        throw new TypeError(`Invalid audio codec: ${options.audio.codec}. Must be a string.`);\n      }\n      if (!Number.isInteger(options.audio.numberOfChannels) || options.audio.numberOfChannels <= 0) {\n        throw new TypeError(\n          `Invalid number of audio channels: ${options.audio.numberOfChannels}. Must be a positive integer.`\n        );\n      }\n      if (!Number.isInteger(options.audio.sampleRate) || options.audio.sampleRate <= 0) {\n        throw new TypeError(\n          `Invalid audio sample rate: ${options.audio.sampleRate}. Must be a positive integer.`\n        );\n      }\n      if (options.audio.bitDepth !== void 0) {\n        if (!Number.isInteger(options.audio.bitDepth) || options.audio.bitDepth <= 0) {\n          throw new TypeError(\n            `Invalid audio bit depth: ${options.audio.bitDepth}. Must be a positive integer.`\n          );\n        }\n      }\n    }\n    if (options.subtitles) {\n      if (typeof options.subtitles.codec !== \"string\") {\n        throw new TypeError(`Invalid subtitles codec: ${options.subtitles.codec}. Must be a string.`);\n      }\n    }\n    if (options.type !== void 0 && ![\"webm\", \"matroska\"].includes(options.type)) {\n      throw new TypeError(`Invalid type: ${options.type}. Must be 'webm' or 'matroska'.`);\n    }\n    if (options.firstTimestampBehavior && !FIRST_TIMESTAMP_BEHAVIORS.includes(options.firstTimestampBehavior)) {\n      throw new TypeError(`Invalid first timestamp behavior: ${options.firstTimestampBehavior}`);\n    }\n    if (options.streaming !== void 0 && typeof options.streaming !== \"boolean\") {\n      throw new TypeError(`Invalid streaming option: ${options.streaming}. Must be a boolean.`);\n    }\n  };\n  _createFileHeader = new WeakSet();\n  createFileHeader_fn = function() {\n    if (__privateGet(this, _writer) instanceof BaseStreamTargetWriter && __privateGet(this, _writer).target.options.onHeader) {\n      __privateGet(this, _writer).startTrackingWrites();\n    }\n    __privateMethod(this, _writeEBMLHeader, writeEBMLHeader_fn).call(this);\n    if (!__privateGet(this, _options).streaming) {\n      __privateMethod(this, _createSeekHead, createSeekHead_fn).call(this);\n    }\n    __privateMethod(this, _createSegmentInfo, createSegmentInfo_fn).call(this);\n    __privateMethod(this, _createCodecPrivatePlaceholders, createCodecPrivatePlaceholders_fn).call(this);\n    __privateMethod(this, _createColourElement, createColourElement_fn).call(this);\n    if (!__privateGet(this, _options).streaming) {\n      __privateMethod(this, _createTracks, createTracks_fn).call(this);\n      __privateMethod(this, _createSegment, createSegment_fn).call(this);\n    } else {\n    }\n    __privateMethod(this, _createCues, createCues_fn).call(this);\n    __privateMethod(this, _maybeFlushStreamingTargetWriter, maybeFlushStreamingTargetWriter_fn).call(this);\n  };\n  _writeEBMLHeader = new WeakSet();\n  writeEBMLHeader_fn = function() {\n    let ebmlHeader = { id: 440786851 /* EBML */, data: [\n      { id: 17030 /* EBMLVersion */, data: 1 },\n      { id: 17143 /* EBMLReadVersion */, data: 1 },\n      { id: 17138 /* EBMLMaxIDLength */, data: 4 },\n      { id: 17139 /* EBMLMaxSizeLength */, data: 8 },\n      { id: 17026 /* DocType */, data: __privateGet(this, _options).type ?? \"webm\" },\n      { id: 17031 /* DocTypeVersion */, data: 2 },\n      { id: 17029 /* DocTypeReadVersion */, data: 2 }\n    ] };\n    __privateGet(this, _writer).writeEBML(ebmlHeader);\n  };\n  _createCodecPrivatePlaceholders = new WeakSet();\n  createCodecPrivatePlaceholders_fn = function() {\n    __privateSet(this, _videoCodecPrivate, { id: 236 /* Void */, size: 4, data: new Uint8Array(CODEC_PRIVATE_MAX_SIZE) });\n    __privateSet(this, _audioCodecPrivate, { id: 236 /* Void */, size: 4, data: new Uint8Array(CODEC_PRIVATE_MAX_SIZE) });\n    __privateSet(this, _subtitleCodecPrivate, { id: 236 /* Void */, size: 4, data: new Uint8Array(CODEC_PRIVATE_MAX_SIZE) });\n  };\n  _createColourElement = new WeakSet();\n  createColourElement_fn = function() {\n    __privateSet(this, _colourElement, { id: 21936 /* Colour */, data: [\n      { id: 21937 /* MatrixCoefficients */, data: 2 },\n      { id: 21946 /* TransferCharacteristics */, data: 2 },\n      { id: 21947 /* Primaries */, data: 2 },\n      { id: 21945 /* Range */, data: 0 }\n    ] });\n  };\n  _createSeekHead = new WeakSet();\n  createSeekHead_fn = function() {\n    const kaxCues = new Uint8Array([28, 83, 187, 107]);\n    const kaxInfo = new Uint8Array([21, 73, 169, 102]);\n    const kaxTracks = new Uint8Array([22, 84, 174, 107]);\n    let seekHead = { id: 290298740 /* SeekHead */, data: [\n      { id: 19899 /* Seek */, data: [\n        { id: 21419 /* SeekID */, data: kaxCues },\n        { id: 21420 /* SeekPosition */, size: 5, data: 0 }\n      ] },\n      { id: 19899 /* Seek */, data: [\n        { id: 21419 /* SeekID */, data: kaxInfo },\n        { id: 21420 /* SeekPosition */, size: 5, data: 0 }\n      ] },\n      { id: 19899 /* Seek */, data: [\n        { id: 21419 /* SeekID */, data: kaxTracks },\n        { id: 21420 /* SeekPosition */, size: 5, data: 0 }\n      ] }\n    ] };\n    __privateSet(this, _seekHead, seekHead);\n  };\n  _createSegmentInfo = new WeakSet();\n  createSegmentInfo_fn = function() {\n    let segmentDuration = { id: 17545 /* Duration */, data: new EBMLFloat64(0) };\n    __privateSet(this, _segmentDuration, segmentDuration);\n    let segmentInfo = { id: 357149030 /* Info */, data: [\n      { id: 2807729 /* TimestampScale */, data: 1e6 },\n      { id: 19840 /* MuxingApp */, data: APP_NAME },\n      { id: 22337 /* WritingApp */, data: APP_NAME },\n      !__privateGet(this, _options).streaming ? segmentDuration : null\n    ] };\n    __privateSet(this, _segmentInfo, segmentInfo);\n  };\n  _createTracks = new WeakSet();\n  createTracks_fn = function() {\n    let tracksElement = { id: 374648427 /* Tracks */, data: [] };\n    __privateSet(this, _tracksElement, tracksElement);\n    if (__privateGet(this, _options).video) {\n      tracksElement.data.push({ id: 174 /* TrackEntry */, data: [\n        { id: 215 /* TrackNumber */, data: VIDEO_TRACK_NUMBER },\n        { id: 29637 /* TrackUID */, data: VIDEO_TRACK_NUMBER },\n        { id: 131 /* TrackType */, data: VIDEO_TRACK_TYPE },\n        { id: 134 /* CodecID */, data: __privateGet(this, _options).video.codec },\n        __privateGet(this, _videoCodecPrivate),\n        __privateGet(this, _options).video.frameRate ? { id: 2352003 /* DefaultDuration */, data: 1e9 / __privateGet(this, _options).video.frameRate } : null,\n        { id: 224 /* Video */, data: [\n          { id: 176 /* PixelWidth */, data: __privateGet(this, _options).video.width },\n          { id: 186 /* PixelHeight */, data: __privateGet(this, _options).video.height },\n          __privateGet(this, _options).video.alpha ? { id: 21440 /* AlphaMode */, data: 1 } : null,\n          __privateGet(this, _colourElement)\n        ] }\n      ] });\n    }\n    if (__privateGet(this, _options).audio) {\n      __privateSet(this, _audioCodecPrivate, __privateGet(this, _options).streaming ? __privateGet(this, _audioCodecPrivate) || null : { id: 236 /* Void */, size: 4, data: new Uint8Array(CODEC_PRIVATE_MAX_SIZE) });\n      tracksElement.data.push({ id: 174 /* TrackEntry */, data: [\n        { id: 215 /* TrackNumber */, data: AUDIO_TRACK_NUMBER },\n        { id: 29637 /* TrackUID */, data: AUDIO_TRACK_NUMBER },\n        { id: 131 /* TrackType */, data: AUDIO_TRACK_TYPE },\n        { id: 134 /* CodecID */, data: __privateGet(this, _options).audio.codec },\n        __privateGet(this, _audioCodecPrivate),\n        { id: 225 /* Audio */, data: [\n          { id: 181 /* SamplingFrequency */, data: new EBMLFloat32(__privateGet(this, _options).audio.sampleRate) },\n          { id: 159 /* Channels */, data: __privateGet(this, _options).audio.numberOfChannels },\n          __privateGet(this, _options).audio.bitDepth ? { id: 25188 /* BitDepth */, data: __privateGet(this, _options).audio.bitDepth } : null\n        ] }\n      ] });\n    }\n    if (__privateGet(this, _options).subtitles) {\n      tracksElement.data.push({ id: 174 /* TrackEntry */, data: [\n        { id: 215 /* TrackNumber */, data: SUBTITLE_TRACK_NUMBER },\n        { id: 29637 /* TrackUID */, data: SUBTITLE_TRACK_NUMBER },\n        { id: 131 /* TrackType */, data: SUBTITLE_TRACK_TYPE },\n        { id: 134 /* CodecID */, data: __privateGet(this, _options).subtitles.codec },\n        __privateGet(this, _subtitleCodecPrivate)\n      ] });\n    }\n  };\n  _createSegment = new WeakSet();\n  createSegment_fn = function() {\n    let segment = {\n      id: 408125543 /* Segment */,\n      size: __privateGet(this, _options).streaming ? -1 : SEGMENT_SIZE_BYTES,\n      data: [\n        !__privateGet(this, _options).streaming ? __privateGet(this, _seekHead) : null,\n        __privateGet(this, _segmentInfo),\n        __privateGet(this, _tracksElement)\n      ]\n    };\n    __privateSet(this, _segment, segment);\n    __privateGet(this, _writer).writeEBML(segment);\n    if (__privateGet(this, _writer) instanceof BaseStreamTargetWriter && __privateGet(this, _writer).target.options.onHeader) {\n      let { data, start } = __privateGet(this, _writer).getTrackedWrites();\n      __privateGet(this, _writer).target.options.onHeader(data, start);\n    }\n  };\n  _createCues = new WeakSet();\n  createCues_fn = function() {\n    __privateSet(this, _cues, { id: 475249515 /* Cues */, data: [] });\n  };\n  _maybeFlushStreamingTargetWriter = new WeakSet();\n  maybeFlushStreamingTargetWriter_fn = function() {\n    if (__privateGet(this, _writer) instanceof StreamTargetWriter) {\n      __privateGet(this, _writer).flush();\n    }\n  };\n  _segmentDataOffset = new WeakSet();\n  segmentDataOffset_get = function() {\n    return __privateGet(this, _writer).dataOffsets.get(__privateGet(this, _segment));\n  };\n  _writeVideoDecoderConfig = new WeakSet();\n  writeVideoDecoderConfig_fn = function(meta) {\n    if (!meta.decoderConfig)\n      return;\n    if (meta.decoderConfig.colorSpace) {\n      let colorSpace = meta.decoderConfig.colorSpace;\n      __privateSet(this, _colorSpace, colorSpace);\n      __privateGet(this, _colourElement).data = [\n        { id: 21937 /* MatrixCoefficients */, data: {\n          \"rgb\": 1,\n          \"bt709\": 1,\n          \"bt470bg\": 5,\n          \"smpte170m\": 6\n        }[colorSpace.matrix] },\n        { id: 21946 /* TransferCharacteristics */, data: {\n          \"bt709\": 1,\n          \"smpte170m\": 6,\n          \"iec61966-2-1\": 13\n        }[colorSpace.transfer] },\n        { id: 21947 /* Primaries */, data: {\n          \"bt709\": 1,\n          \"bt470bg\": 5,\n          \"smpte170m\": 6\n        }[colorSpace.primaries] },\n        { id: 21945 /* Range */, data: [1, 2][Number(colorSpace.fullRange)] }\n      ];\n      if (!__privateGet(this, _options).streaming) {\n        let endPos = __privateGet(this, _writer).pos;\n        __privateGet(this, _writer).seek(__privateGet(this, _writer).offsets.get(__privateGet(this, _colourElement)));\n        __privateGet(this, _writer).writeEBML(__privateGet(this, _colourElement));\n        __privateGet(this, _writer).seek(endPos);\n      }\n    }\n    if (meta.decoderConfig.description) {\n      if (__privateGet(this, _options).streaming) {\n        __privateSet(this, _videoCodecPrivate, __privateMethod(this, _createCodecPrivateElement, createCodecPrivateElement_fn).call(this, meta.decoderConfig.description));\n      } else {\n        __privateMethod(this, _writeCodecPrivate, writeCodecPrivate_fn).call(this, __privateGet(this, _videoCodecPrivate), meta.decoderConfig.description);\n      }\n    }\n  };\n  _fixVP9ColorSpace = new WeakSet();\n  fixVP9ColorSpace_fn = function(chunk) {\n    if (chunk.type !== \"key\")\n      return;\n    if (!__privateGet(this, _colorSpace))\n      return;\n    let i = 0;\n    if (readBits(chunk.data, 0, 2) !== 2)\n      return;\n    i += 2;\n    let profile = (readBits(chunk.data, i + 1, i + 2) << 1) + readBits(chunk.data, i + 0, i + 1);\n    i += 2;\n    if (profile === 3)\n      i++;\n    let showExistingFrame = readBits(chunk.data, i + 0, i + 1);\n    i++;\n    if (showExistingFrame)\n      return;\n    let frameType = readBits(chunk.data, i + 0, i + 1);\n    i++;\n    if (frameType !== 0)\n      return;\n    i += 2;\n    let syncCode = readBits(chunk.data, i + 0, i + 24);\n    i += 24;\n    if (syncCode !== 4817730)\n      return;\n    if (profile >= 2)\n      i++;\n    let colorSpaceID = {\n      \"rgb\": 7,\n      \"bt709\": 2,\n      \"bt470bg\": 1,\n      \"smpte170m\": 3\n    }[__privateGet(this, _colorSpace).matrix];\n    writeBits(chunk.data, i + 0, i + 3, colorSpaceID);\n  };\n  _writeSubtitleChunks = new WeakSet();\n  writeSubtitleChunks_fn = function() {\n    let lastWrittenMediaTimestamp = Math.min(\n      __privateGet(this, _options).video ? __privateGet(this, _lastVideoTimestamp) : Infinity,\n      __privateGet(this, _options).audio ? __privateGet(this, _lastAudioTimestamp) : Infinity\n    );\n    let queue = __privateGet(this, _subtitleChunkQueue);\n    while (queue.length > 0 && queue[0].timestamp <= lastWrittenMediaTimestamp) {\n      __privateMethod(this, _writeBlock, writeBlock_fn).call(this, queue.shift(), !__privateGet(this, _options).video && !__privateGet(this, _options).audio);\n    }\n  };\n  _createInternalChunk = new WeakSet();\n  createInternalChunk_fn = function(data, type, timestamp, trackNumber, duration, additions) {\n    let adjustedTimestamp = __privateMethod(this, _validateTimestamp, validateTimestamp_fn).call(this, timestamp, trackNumber);\n    let internalChunk = {\n      data,\n      additions,\n      type,\n      timestamp: adjustedTimestamp,\n      duration,\n      trackNumber\n    };\n    return internalChunk;\n  };\n  _validateTimestamp = new WeakSet();\n  validateTimestamp_fn = function(timestamp, trackNumber) {\n    let lastTimestamp = trackNumber === VIDEO_TRACK_NUMBER ? __privateGet(this, _lastVideoTimestamp) : trackNumber === AUDIO_TRACK_NUMBER ? __privateGet(this, _lastAudioTimestamp) : __privateGet(this, _lastSubtitleTimestamp);\n    if (trackNumber !== SUBTITLE_TRACK_NUMBER) {\n      let firstTimestamp = trackNumber === VIDEO_TRACK_NUMBER ? __privateGet(this, _firstVideoTimestamp) : __privateGet(this, _firstAudioTimestamp);\n      if (__privateGet(this, _options).firstTimestampBehavior === \"strict\" && lastTimestamp === -1 && timestamp !== 0) {\n        throw new Error(\n          `The first chunk for your media track must have a timestamp of 0 (received ${timestamp}). Non-zero first timestamps are often caused by directly piping frames or audio data from a MediaStreamTrack into the encoder. Their timestamps are typically relative to the age of the document, which is probably what you want.\n\nIf you want to offset all timestamps of a track such that the first one is zero, set firstTimestampBehavior: 'offset' in the options.\nIf you want to allow non-zero first timestamps, set firstTimestampBehavior: 'permissive'.\n`\n        );\n      } else if (__privateGet(this, _options).firstTimestampBehavior === \"offset\") {\n        timestamp -= firstTimestamp;\n      }\n    }\n    if (timestamp < lastTimestamp) {\n      throw new Error(\n        `Timestamps must be monotonically increasing (went from ${lastTimestamp} to ${timestamp}).`\n      );\n    }\n    if (timestamp < 0) {\n      throw new Error(`Timestamps must be non-negative (received ${timestamp}).`);\n    }\n    return timestamp;\n  };\n  _writeBlock = new WeakSet();\n  writeBlock_fn = function(chunk, canCreateNewCluster) {\n    if (__privateGet(this, _options).streaming && !__privateGet(this, _tracksElement)) {\n      __privateMethod(this, _createTracks, createTracks_fn).call(this);\n      __privateMethod(this, _createSegment, createSegment_fn).call(this);\n    }\n    let msTimestamp = Math.floor(chunk.timestamp / 1e3);\n    let shouldCreateNewClusterFromKeyFrame = canCreateNewCluster && chunk.type === \"key\" && msTimestamp - __privateGet(this, _currentClusterTimestamp) >= 1e3;\n    if (!__privateGet(this, _currentCluster) || shouldCreateNewClusterFromKeyFrame) {\n      __privateMethod(this, _createNewCluster, createNewCluster_fn).call(this, msTimestamp);\n    }\n    let relativeTimestamp = msTimestamp - __privateGet(this, _currentClusterTimestamp);\n    if (relativeTimestamp < 0) {\n      return;\n    }\n    let clusterIsTooLong = relativeTimestamp >= MAX_CHUNK_LENGTH_MS;\n    if (clusterIsTooLong) {\n      throw new Error(\n        `Current Matroska cluster exceeded its maximum allowed length of ${MAX_CHUNK_LENGTH_MS} milliseconds. In order to produce a correct WebM file, you must pass in a key frame at least every ${MAX_CHUNK_LENGTH_MS} milliseconds.`\n      );\n    }\n    let prelude = new Uint8Array(4);\n    let view = new DataView(prelude.buffer);\n    view.setUint8(0, 128 | chunk.trackNumber);\n    view.setInt16(1, relativeTimestamp, false);\n    if (chunk.duration === void 0 && !chunk.additions) {\n      view.setUint8(3, Number(chunk.type === \"key\") << 7);\n      let simpleBlock = { id: 163 /* SimpleBlock */, data: [\n        prelude,\n        chunk.data\n      ] };\n      __privateGet(this, _writer).writeEBML(simpleBlock);\n    } else {\n      let msDuration = Math.floor(chunk.duration / 1e3);\n      let blockGroup = { id: 160 /* BlockGroup */, data: [\n        { id: 161 /* Block */, data: [\n          prelude,\n          chunk.data\n        ] },\n        chunk.duration !== void 0 ? { id: 155 /* BlockDuration */, data: msDuration } : null,\n        chunk.additions ? { id: 30113 /* BlockAdditions */, data: chunk.additions } : null\n      ] };\n      __privateGet(this, _writer).writeEBML(blockGroup);\n    }\n    __privateSet(this, _duration, Math.max(__privateGet(this, _duration), msTimestamp));\n  };\n  _createCodecPrivateElement = new WeakSet();\n  createCodecPrivateElement_fn = function(data) {\n    return { id: 25506 /* CodecPrivate */, size: 4, data: new Uint8Array(data) };\n  };\n  _writeCodecPrivate = new WeakSet();\n  writeCodecPrivate_fn = function(element, data) {\n    let endPos = __privateGet(this, _writer).pos;\n    __privateGet(this, _writer).seek(__privateGet(this, _writer).offsets.get(element));\n    let codecPrivateElementSize = 2 + 4 + data.byteLength;\n    let voidDataSize = CODEC_PRIVATE_MAX_SIZE - codecPrivateElementSize;\n    if (voidDataSize < 0) {\n      let newByteLength = data.byteLength + voidDataSize;\n      if (data instanceof ArrayBuffer) {\n        data = data.slice(0, newByteLength);\n      } else {\n        data = data.buffer.slice(0, newByteLength);\n      }\n      voidDataSize = 0;\n    }\n    element = [\n      __privateMethod(this, _createCodecPrivateElement, createCodecPrivateElement_fn).call(this, data),\n      { id: 236 /* Void */, size: 4, data: new Uint8Array(voidDataSize) }\n    ];\n    __privateGet(this, _writer).writeEBML(element);\n    __privateGet(this, _writer).seek(endPos);\n  };\n  _createNewCluster = new WeakSet();\n  createNewCluster_fn = function(timestamp) {\n    if (__privateGet(this, _currentCluster) && !__privateGet(this, _options).streaming) {\n      __privateMethod(this, _finalizeCurrentCluster, finalizeCurrentCluster_fn).call(this);\n    }\n    if (__privateGet(this, _writer) instanceof BaseStreamTargetWriter && __privateGet(this, _writer).target.options.onCluster) {\n      __privateGet(this, _writer).startTrackingWrites();\n    }\n    __privateSet(this, _currentCluster, {\n      id: 524531317 /* Cluster */,\n      size: __privateGet(this, _options).streaming ? -1 : CLUSTER_SIZE_BYTES,\n      data: [\n        { id: 231 /* Timestamp */, data: timestamp }\n      ]\n    });\n    __privateGet(this, _writer).writeEBML(__privateGet(this, _currentCluster));\n    __privateSet(this, _currentClusterTimestamp, timestamp);\n    let clusterOffsetFromSegment = __privateGet(this, _writer).offsets.get(__privateGet(this, _currentCluster)) - __privateGet(this, _segmentDataOffset, segmentDataOffset_get);\n    __privateGet(this, _cues).data.push({ id: 187 /* CuePoint */, data: [\n      { id: 179 /* CueTime */, data: timestamp },\n      __privateGet(this, _options).video ? { id: 183 /* CueTrackPositions */, data: [\n        { id: 247 /* CueTrack */, data: VIDEO_TRACK_NUMBER },\n        { id: 241 /* CueClusterPosition */, data: clusterOffsetFromSegment }\n      ] } : null,\n      __privateGet(this, _options).audio ? { id: 183 /* CueTrackPositions */, data: [\n        { id: 247 /* CueTrack */, data: AUDIO_TRACK_NUMBER },\n        { id: 241 /* CueClusterPosition */, data: clusterOffsetFromSegment }\n      ] } : null\n    ] });\n  };\n  _finalizeCurrentCluster = new WeakSet();\n  finalizeCurrentCluster_fn = function() {\n    let clusterSize = __privateGet(this, _writer).pos - __privateGet(this, _writer).dataOffsets.get(__privateGet(this, _currentCluster));\n    let endPos = __privateGet(this, _writer).pos;\n    __privateGet(this, _writer).seek(__privateGet(this, _writer).offsets.get(__privateGet(this, _currentCluster)) + 4);\n    __privateGet(this, _writer).writeEBMLVarInt(clusterSize, CLUSTER_SIZE_BYTES);\n    __privateGet(this, _writer).seek(endPos);\n    if (__privateGet(this, _writer) instanceof BaseStreamTargetWriter && __privateGet(this, _writer).target.options.onCluster) {\n      let { data, start } = __privateGet(this, _writer).getTrackedWrites();\n      __privateGet(this, _writer).target.options.onCluster(data, start, __privateGet(this, _currentClusterTimestamp));\n    }\n  };\n  _ensureNotFinalized = new WeakSet();\n  ensureNotFinalized_fn = function() {\n    if (__privateGet(this, _finalized)) {\n      throw new Error(\"Cannot add new video or audio chunks after the file has been finalized.\");\n    }\n  };\n\n  // src/subtitles.ts\n  var cueBlockHeaderRegex = /(?:(.+?)\\n)?((?:\\d{2}:)?\\d{2}:\\d{2}.\\d{3})\\s+-->\\s+((?:\\d{2}:)?\\d{2}:\\d{2}.\\d{3})/g;\n  var preambleStartRegex = /^WEBVTT.*?\\n{2}/;\n  var timestampRegex = /(?:(\\d{2}):)?(\\d{2}):(\\d{2}).(\\d{3})/;\n  var inlineTimestampRegex = /<(?:(\\d{2}):)?(\\d{2}):(\\d{2}).(\\d{3})>/g;\n  var textEncoder = new TextEncoder();\n  var _options2, _config, _preambleSeen, _preambleBytes, _preambleEmitted, _parseTimestamp, parseTimestamp_fn, _formatTimestamp, formatTimestamp_fn;\n  var SubtitleEncoder = class {\n    constructor(options) {\n      __privateAdd(this, _parseTimestamp);\n      __privateAdd(this, _formatTimestamp);\n      __privateAdd(this, _options2, void 0);\n      __privateAdd(this, _config, void 0);\n      __privateAdd(this, _preambleSeen, false);\n      __privateAdd(this, _preambleBytes, void 0);\n      __privateAdd(this, _preambleEmitted, false);\n      __privateSet(this, _options2, options);\n    }\n    configure(config) {\n      if (config.codec !== \"webvtt\") {\n        throw new Error(\"Codec must be 'webvtt'.\");\n      }\n      __privateSet(this, _config, config);\n    }\n    encode(text) {\n      if (!__privateGet(this, _config)) {\n        throw new Error(\"Encoder not configured.\");\n      }\n      text = text.replace(\"\\r\\n\", \"\\n\").replace(\"\\r\", \"\\n\");\n      cueBlockHeaderRegex.lastIndex = 0;\n      let match;\n      if (!__privateGet(this, _preambleSeen)) {\n        if (!preambleStartRegex.test(text)) {\n          let error = new Error(\"WebVTT preamble incorrect.\");\n          __privateGet(this, _options2).error(error);\n          throw error;\n        }\n        match = cueBlockHeaderRegex.exec(text);\n        let preamble = text.slice(0, match?.index ?? text.length).trimEnd();\n        if (!preamble) {\n          let error = new Error(\"No WebVTT preamble provided.\");\n          __privateGet(this, _options2).error(error);\n          throw error;\n        }\n        __privateSet(this, _preambleBytes, textEncoder.encode(preamble));\n        __privateSet(this, _preambleSeen, true);\n        if (match) {\n          text = text.slice(match.index);\n          cueBlockHeaderRegex.lastIndex = 0;\n        }\n      }\n      while (match = cueBlockHeaderRegex.exec(text)) {\n        let notes = text.slice(0, match.index);\n        let cueIdentifier = match[1] || \"\";\n        let matchEnd = match.index + match[0].length;\n        let bodyStart = text.indexOf(\"\\n\", matchEnd) + 1;\n        let cueSettings = text.slice(matchEnd, bodyStart).trim();\n        let bodyEnd = text.indexOf(\"\\n\\n\", matchEnd);\n        if (bodyEnd === -1)\n          bodyEnd = text.length;\n        let startTime = __privateMethod(this, _parseTimestamp, parseTimestamp_fn).call(this, match[2]);\n        let endTime = __privateMethod(this, _parseTimestamp, parseTimestamp_fn).call(this, match[3]);\n        let duration = endTime - startTime;\n        let body = text.slice(bodyStart, bodyEnd);\n        let additions = `${cueSettings}\n${cueIdentifier}\n${notes}`;\n        inlineTimestampRegex.lastIndex = 0;\n        body = body.replace(inlineTimestampRegex, (match2) => {\n          let time = __privateMethod(this, _parseTimestamp, parseTimestamp_fn).call(this, match2.slice(1, -1));\n          let offsetTime = time - startTime;\n          return `<${__privateMethod(this, _formatTimestamp, formatTimestamp_fn).call(this, offsetTime)}>`;\n        });\n        text = text.slice(bodyEnd).trimStart();\n        cueBlockHeaderRegex.lastIndex = 0;\n        let chunk = {\n          body: textEncoder.encode(body),\n          additions: additions.trim() === \"\" ? void 0 : textEncoder.encode(additions),\n          timestamp: startTime * 1e3,\n          duration: duration * 1e3\n        };\n        let meta = {};\n        if (!__privateGet(this, _preambleEmitted)) {\n          meta.decoderConfig = {\n            description: __privateGet(this, _preambleBytes)\n          };\n          __privateSet(this, _preambleEmitted, true);\n        }\n        __privateGet(this, _options2).output(chunk, meta);\n      }\n    }\n  };\n  _options2 = new WeakMap();\n  _config = new WeakMap();\n  _preambleSeen = new WeakMap();\n  _preambleBytes = new WeakMap();\n  _preambleEmitted = new WeakMap();\n  _parseTimestamp = new WeakSet();\n  parseTimestamp_fn = function(string) {\n    let match = timestampRegex.exec(string);\n    if (!match)\n      throw new Error(\"Expected match.\");\n    return 60 * 60 * 1e3 * Number(match[1] || \"0\") + 60 * 1e3 * Number(match[2]) + 1e3 * Number(match[3]) + Number(match[4]);\n  };\n  _formatTimestamp = new WeakSet();\n  formatTimestamp_fn = function(timestamp) {\n    let hours = Math.floor(timestamp / (60 * 60 * 1e3));\n    let minutes = Math.floor(timestamp % (60 * 60 * 1e3) / (60 * 1e3));\n    let seconds = Math.floor(timestamp % (60 * 1e3) / 1e3);\n    let milliseconds = timestamp % 1e3;\n    return hours.toString().padStart(2, \"0\") + \":\" + minutes.toString().padStart(2, \"0\") + \":\" + seconds.toString().padStart(2, \"0\") + \".\" + milliseconds.toString().padStart(3, \"0\");\n  };\n  return __toCommonJS(src_exports);\n})();\nif ( true && typeof module.exports === \"object\") Object.assign(module.exports, WebMMuxer)\n\n\n//# sourceURL=webpack://rf-video-editor-worker/./node_modules/webm-muxer/build/webm-muxer.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_124621__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_124621__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __nested_webpack_require_124621__("./src/index.ts");
/******/ 	
/******/ })()
;
/******/ })()
;
//# sourceMappingURL=worker-frames-to-video.worker.js.map